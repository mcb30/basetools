#!/usr/bin/env python
import string
import EdkLogger

from BuildToolError import *
from DataType import *
from EdkIIWorkspace import *
from BuildInfo import *
from StrGather import *

ItemTypeStringDatabase  = {
    TAB_PCDS_FEATURE_FLAG:'FixedAtBuild',
    TAB_PCDS_FIXED_AT_BUILD:'FixedAtBuild',
    TAB_PCDS_PATCHABLE_IN_MODULE:'BinaryPatch',
    TAB_PCDS_DYNAMIC:'',
    TAB_PCDS_DYNAMIC+"Default":'',
    TAB_PCDS_DYNAMIC+"Vpd":'',
    TAB_PCDS_DYNAMIC+"Hii":'',
    TAB_PCDS_DYNAMIC_EX:'',
    TAB_PCDS_DYNAMIC_EX+"Default":'',
    TAB_PCDS_DYNAMIC_EX+"Vpd":'',
    TAB_PCDS_DYNAMIC_EX+"Hii":'',
}

gDynamicPcd = [TAB_PCDS_DYNAMIC, TAB_PCDS_DYNAMIC+"Default", TAB_PCDS_DYNAMIC+"Vpd", TAB_PCDS_DYNAMIC+"Hii"]
gDynamicExPcd = [TAB_PCDS_DYNAMIC_EX, TAB_PCDS_DYNAMIC_EX+"Default", TAB_PCDS_DYNAMIC_EX+"Vpd", TAB_PCDS_DYNAMIC_EX+"Hii"]

DatumSizeStringDatabase = {'UINT8':'8','UINT16':'16','UINT32':'32','UINT64':'64','BOOLEAN':'BOOLEAN','VOID*':'8'}
DatumSizeStringDatabaseH = {'UINT8':'8','UINT16':'16','UINT32':'32','UINT64':'64','BOOLEAN':'BOOL','VOID*':'PTR'}
DatumSizeStringDatabaseLib = {'UINT8':'8','UINT16':'16','UINT32':'32','UINT64':'64','BOOLEAN':'Bool','VOID*':'Ptr'}

PcdPhaseMap = {
    "PEI_PCD_DRIVER"    :   "PEI",
    "DXE_PCD_DRIVER"    :   "DXE"
}

PcdDatabaseCommonAutoGenH = """
//
// The following definition will be generated by build tool
//

//
// Common definitions
//
typedef UINT8 SKU_ID;

#define PCD_TYPE_SHIFT        28

#define PCD_TYPE_DATA         (0x0 << PCD_TYPE_SHIFT)
#define PCD_TYPE_HII          (0x8 << PCD_TYPE_SHIFT)
#define PCD_TYPE_VPD          (0x4 << PCD_TYPE_SHIFT)
#define PCD_TYPE_SKU_ENABLED  (0x2 << PCD_TYPE_SHIFT)
#define PCD_TYPE_STRING       (0x1 << PCD_TYPE_SHIFT)

#define PCD_TYPE_ALL_SET      (PCD_TYPE_DATA | PCD_TYPE_HII | PCD_TYPE_VPD | PCD_TYPE_SKU_ENABLED | PCD_TYPE_STRING)

#define PCD_DATUM_TYPE_SHIFT  24

#define PCD_DATUM_TYPE_POINTER  (0x0 << PCD_DATUM_TYPE_SHIFT)
#define PCD_DATUM_TYPE_UINT8    (0x1 << PCD_DATUM_TYPE_SHIFT)
#define PCD_DATUM_TYPE_UINT16   (0x2 << PCD_DATUM_TYPE_SHIFT)
#define PCD_DATUM_TYPE_UINT32   (0x4 << PCD_DATUM_TYPE_SHIFT)
#define PCD_DATUM_TYPE_UINT64   (0x8 << PCD_DATUM_TYPE_SHIFT)

#define PCD_DATUM_TYPE_ALL_SET  (PCD_DATUM_TYPE_POINTER | \\
                                 PCD_DATUM_TYPE_UINT8   | \\
                                 PCD_DATUM_TYPE_UINT16  | \\
                                 PCD_DATUM_TYPE_UINT32  | \\
                                 PCD_DATUM_TYPE_UINT64)

#define PCD_DATABASE_OFFSET_MASK (~(PCD_TYPE_ALL_SET | PCD_DATUM_TYPE_ALL_SET))

typedef struct  {
  UINT32  ExTokenNumber;
  UINT16  LocalTokenNumber;   // PCD Number of this particular platform build
  UINT16  ExGuidIndex;        // Index of GuidTable
} DYNAMICEX_MAPPING;

typedef struct {
  UINT32  SkuDataStartOffset; //We have to use offsetof MACRO as we don't know padding done by compiler
  UINT32  SkuIdTableOffset;   //Offset from the PCD_DB
} SKU_HEAD;

typedef struct {
  UINT16  GuidTableIndex;     // Offset in Guid Table in units of GUID.
  UINT16  StringIndex;        // Offset in String Table in units of UINT16.
  UINT16  Offset;             // Offset in Variable
  UINT16  DefaultValueOffset; // Offset of the Default Value
} VARIABLE_HEAD;

typedef  struct {
  UINT32  Offset;
} VPD_HEAD;

typedef UINT16 STRING_HEAD;

typedef UINT16 SIZE_INFO;

#define offsetof(s,m)  (UINT32) (UINTN) &(((s *)0)->m)

"""

PcdDatabaseEpilogueAutoGenH = """
typedef struct {
  PEI_PCD_DATABASE PeiDb;
  DXE_PCD_DATABASE DxeDb;
} PCD_DATABASE;

#define PCD_TOTAL_TOKEN_NUMBER (PEI_LOCAL_TOKEN_NUMBER + DXE_LOCAL_TOKEN_NUMBER)

"""

PcdDatabaseAutoGenH = """
#define ${PHASE}_GUID_TABLE_SIZE                ${GUID_TABLE_SIZE}
#define ${PHASE}_STRING_TABLE_SIZE              ${STRING_TABLE_SIZE}
#define ${PHASE}_SKUID_TABLE_SIZE               ${SKUID_TABLE_SIZE}
#define ${PHASE}_LOCAL_TOKEN_NUMBER_TABLE_SIZE  ${LOCAL_TOKEN_NUMBER_TABLE_SIZE}
#define ${PHASE}_LOCAL_TOKEN_NUMBER             ${LOCAL_TOKEN_NUMBER}
#define ${PHASE}_EXMAPPING_TABLE_SIZE           ${EXMAPPING_TABLE_SIZE}
#define ${PHASE}_EX_TOKEN_NUMBER                ${EX_TOKEN_NUMBER}
#define ${PHASE}_SIZE_TABLE_SIZE                ${SIZE_TABLE_SIZE}
#define ${PHASE}_GUID_TABLE_EMPTY               ${GUID_TABLE_EMPTY}
#define ${PHASE}_STRING_TABLE_EMPTY             ${STRING_TABLE_EMPTY}
#define ${PHASE}_SKUID_TABLE_EMPTY              ${SKUID_TABLE_EMPTY}
#define ${PHASE}_DATABASE_EMPTY                 ${DATABASE_EMPTY}
#define ${PHASE}_EXMAP_TABLE_EMPTY              ${EXMAP_TABLE_EMPTY}

typedef struct {
${BEGIN}  UINT64             ${INIT_CNAME_DECL_UITN64}_${INIT_GUID_DECL_UINT64}[${INIT_NUMSKUS_DECL_UINT64}];
${END}
${BEGIN}  UINT64             ${VARDEF_CNAME_UINT64}_${VARDEF_GUID_UINT64}_VariableDefault_${VARDEF_SKUID_UINT64};
${END}
${BEGIN}  UINT32             ${INIT_CNAME_DECL_UINT32}_${INIT_GUID_DECL_UINT32}[${INIT_NUMSKUS_DECL_UINT32}];
${END}
${BEGIN}  UINT32             ${VARDEF_CNAME_UINT32}_${VARDEF_GUID_UINT32}_VariableDefault_${VARDEF_SKUID_UINT32};
${END}
${BEGIN}  VPD_HEAD           ${VPD_HEAD_CNAME_DECL}_${VPD_HEAD_GUID_DECL}[${VPD_HEAD_NUMSKUS_DECL}];
${END}
  DYNAMICEX_MAPPING  ExMapTable[${PHASE}_EXMAPPING_TABLE_SIZE];
  UINT32             LocalTokenNumberTable[${PHASE}_LOCAL_TOKEN_NUMBER_TABLE_SIZE];
  GUID               GuidTable[${PHASE}_GUID_TABLE_SIZE];
${BEGIN}  STRING_HEAD        ${STRING_HEAD_CNAME_DECL}_${STRING_HEAD_GUID_DECL}[${STRING_HEAD_NUMSKUS_DECL}];
${END}
${BEGIN}  VARIABLE_HEAD      ${VARIABLE_HEAD_CNAME_DECL}_${VARIABLE_HEAD_GUID_DECL}[${VARIABLE_HEAD_NUMSKUS_DECL}];
${END}
${BEGIN}  UINT16             StringTable${STRING_TABLE_INDEX}[${STRING_TABLE_LENGTH}]; /* ${STRING_TABLE_CNAME}_${STRING_TABLE_GUID} */
${END}
  SIZE_INFO          SizeTable[${PHASE}_SIZE_TABLE_SIZE];
${BEGIN}  UINT16             ${INIT_CNAME_DECL_UINT16}_${INIT_GUID_DECL_UINT16}[${INIT_NUMSKUS_DECL_UINT16}];
${END}
${BEGIN}  UINT16             ${VARDEF_CNAME_UINT16}_${VARDEF_GUID_UINT16}_VariableDefault_${VARDEF_SKUID_UINT16};
${END}
${BEGIN}  UINT8              ${INIT_CNAME_DECL_UINT8}_${INIT_GUID_DECL_UINT8}[${INIT_NUMSKUS_DECL_UINT8}];
${END}
${BEGIN}  UINT8              ${VARDEF_CNAME_UINT8}_${VARDEF_GUID_UINT8}_VariableDefault_${VARDEF_SKUID_UINT8};
${END}
${BEGIN}  BOOLEAN            ${INIT_CNAME_DECL_BOOLEAN}_${INIT_GUID_DECL_BOOLEAN}[${INIT_NUMSKUS_BOOLEAN}];
${END}
${BEGIN}  BOOLEAN            ${VARDEF_CNAME_BOOLEAN}_${VARDEF_GUID_BOOLEAN}_VariableDefault_${VARDEF_SKUID_BOOLEAN};
${END}
  UINT8              SkuIdTable[${PHASE}_SKUID_TABLE_SIZE];
${SYSTEM_SKU_ID}
} ${PHASE}_PCD_DATABASE_INIT;

typedef struct {
${PCD_DATABASE_UNINIT_EMPTY}
${BEGIN}  UINT64   ${UNINIT_CNAME_DECL_UINT64}_${UNINIT_GUID_DECL_UINT64}[${UNINIT_NUMSKUS_DECL_UINT64}];
${END}
${BEGIN}  UINT32   ${UNINIT_CNAME_DECL_UINT32}_${UNINIT_GUID_DECL_UINT32}[${UNINIT_NUMSKUS_DECL_UINT32}];
${END}
${BEGIN}  UINT16   ${UNINIT_CNAME_DECL_UINT16}_${UNINIT_GUID_DECL_UINT16}[${UNINIT_NUMSKUS_DECL_UINT16}];
${END}
${BEGIN}  UINT8    ${UNINIT_CNAME_DECL_UINT8}_${UNINIT_GUID_DECL_UINT8}[${UNINIT_NUMSKUS_DECL_UINT8}];
${END}
${BEGIN}  BOOLEAN  ${UNINIT_CNAME_DECL_BOOLEAN}_${UNINIT_GUID_DECL_BOOLEAN}[${UNINIT_NUMSKUS_DECL_BOOLEAN}];
${END}
} ${PHASE}_PCD_DATABASE_UNINIT;

#define PCD_${PHASE}_SERVICE_DRIVER_VERSION         2

typedef struct {
  ${PHASE}_PCD_DATABASE_INIT    Init;
  ${PHASE}_PCD_DATABASE_UNINIT  Uninit;
} ${PHASE}_PCD_DATABASE;

#define ${PHASE}_NEX_TOKEN_NUMBER (${PHASE}_LOCAL_TOKEN_NUMBER - ${PHASE}_EX_TOKEN_NUMBER)
"""

EmptyPcdDatabaseAutoGenC = """
${PHASE}_PCD_DATABASE_INIT g${PHASE}PcdDbInit = {
  /* ExMapTable */
  {
    {0, 0, 0}
  },
  /* LocalTokenNumberTable */
  {
    0
  },
  /* GuidTable */
  {
    {0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}
  },
  /* StringTable */
  { 0 },
  /* SizeTable */
  {
    0, 0
  },
  /* SkuIdTable */
  { 0 },
  ${SYSTEM_SKU_ID_VALUE}
};
"""

PcdDatabaseAutoGenC = """
${PHASE}_PCD_DATABASE_INIT g${PHASE}PcdDbInit = {
${BEGIN}  { ${INIT_VALUE_UINT64} }, /*  ${INIT_CNAME_DECL_UINT64}_${INIT_GUID_DECL_UINT64}[${INIT_NUMSKUS_DECL_UINT64}] */
${END}
${BEGIN}  ${VARDEF_VALUE_UINT64}, /* ${VARDEF_CNAME_UINT64}_${VARDEF_GUID_UINT64}_VariableDefault_${VARDEF_SKUID_UINT64} */
${END}
${BEGIN}  { ${INIT_VALUE_UINT32} }, /*  ${INIT_CNAME_DECL_UINT32}_${INIT_GUID_DECL_UINT32}[${INIT_NUMSKUS_DECL_UINT32}] */
${END}
${BEGIN}  ${VARDEF_VALUE_UINT32}, /* ${VARDEF_CNAME_UINT32}_${VARDEF_GUID_UINT32}_VariableDefault_${VARDEF_SKUID_UINT32} */
${END}
  /* VPD */
${BEGIN}  { ${VPD_HEAD_VALUE} }, /* ${VPD_HEAD_CNAME_DECL}_${VPD_HEAD_GUID_DECL}[${VPD_HEAD_NUMSKUS_DECL}] */
${END}
  /* ExMapTable */
  {
${BEGIN}    { ${EXMAPPING_TABLE_EXTOKEN}, ${EXMAPPING_TABLE_LOCAL_TOKEN}, ${EXMAPPING_TABLE_GUID_INDEX} },
${END}
  },
  /* LocalTokenNumberTable */
  {
${BEGIN}    offsetof(${PHASE}_PCD_DATABASE, ${TOKEN_INIT}.${TOKEN_CNAME}_${TOKEN_GUID}) | ${TOKEN_TYPE},
${END}
  },
  /* GuidTable */
  {
${BEGIN}    ${GUID_STRUCTURE},
${END}
  },
${BEGIN}  { ${STRING_HEAD_VALUE} }, /* ${STRING_HEAD_CNAME_DECL}_${STRING_HEAD_GUID_DECL}[${STRING_HEAD_NUMSKUS_DECL}] */
${END}
${BEGIN}  /* ${VARIABLE_HEAD_CNAME_DECL}_${VARIABLE_HEAD_GUID_DECL}[${VARIABLE_HEAD_NUMSKUS_DECL}] */
  {
    ${VARIABLE_HEAD_VALUE}
  },
${END}
 /* StringTable */
${BEGIN}  ${STRING_TABLE_VALUE}, /* ${STRING_TABLE_CNAME}_${STRING_TABLE_GUID} */
${END}
  /* SizeTable */
  {
${BEGIN}    ${SIZE_TABLE_CURRENT_LENGTH}, ${SIZE_TABLE_MAXIMUM_LENGTH}, /* ${SIZE_TABLE_CNAME}_${SIZE_TABLE_GUID} */
${END}
  },
${BEGIN}  { ${INIT_VALUE_UINT16} }, /*  ${INIT_CNAME_DECL_UINT16}_${INIT_GUID_DECL_UINT16}[${INIT_NUMSKUS_DECL_UINT16}] */
${END}
${BEGIN}  ${VARDEF_VALUE_UINT16}, /* ${VARDEF_CNAME_UINT16}_${VARDEF_GUID_UINT16}_VariableDefault_${VARDEF_SKUID_UINT16} */
${END}
${BEGIN}  { ${INIT_VALUE_UINT8} }, /*  ${INIT_CNAME_DECL_UINT8}_${INIT_GUID_DECL_UINT8}[${INIT_NUMSKUS_DECL_UINT8}] */
${END}
${BEGIN}  ${VARDEF_VALUE_UINT8}, /* ${VARDEF_CNAME_UINT8}_${VARDEF_GUID_UINT8}_VariableDefault_${VARDEF_SKUID_UINT8} */
${END}
${BEGIN}  { ${INIT_VALUE_BOOLEAN} }, /*  ${INIT_CNAME_DECL_BOOLEAN}_${INIT_GUID_DECL_BOOLEAN}[${INIT_NUMSKUS_DECL_BOOLEAN}] */
${END}
${BEGIN}  ${VARDEF_VALUE_BOOLEAN}, /* ${VARDEF_CNAME_BOOLEAN}_${VARDEF_GUID_BOOLEAN}_VariableDefault_${VARDEF_SKUID_BOOLEAN} */
${END}
  /* SkuIdTable */
  { ${BEGIN}${SKUID_VALUE}, ${END} },
  ${SYSTEM_SKU_ID_VALUE}
};
"""

#
# AutoGen File Header Templates
#
AutoGenHeaderString = """\
/**
  DO NOT EDIT
  FILE auto-generated
  Module name:
    $FileName
  Abstract:       Auto-generated $FileName for building module or library.
**/
"""

AutoGenHPrologueString = """
#ifndef _AUTOGENH_${Guid}
#define _AUTOGENH_${Guid}

extern int __make_me_compile_correctly;
"""

AutoGenHEpilogueString = """
#endif
"""

#
# PEI Core Entry Point Templates
#
PeiCoreEntryPointString = """
EFI_STATUS
${Function} (
  IN EFI_PEI_STARTUP_DESCRIPTOR  *PeiStartupDescriptor,
  IN VOID                        *OldCoreData
  );

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_PEI_STARTUP_DESCRIPTOR  *PeiStartupDescriptor,
  IN VOID                        *OldCoreData
  )

{
  return ${Function} (PeiStartupDescriptor, OldCoreData);
}
"""

#
# DXE Core Entry Point Templates
#
DxeCoreEntryPointString = """
const UINT32 _gUefiDriverRevision = 0;

VOID
${Function} (
  IN VOID  *HobStart
  );

VOID
EFIAPI
ProcessModuleEntryPointList (
  IN VOID  *HobStart
  )

{
  ${Function} (HobStart);
}
"""

#
# PEIM Entry Point Templates
#
PeimEntryPointString = [
"""
GLOBAL_REMOVE_IF_UNREFERENCED const UINT32 _gPeimRevision = 0;

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_FFS_FILE_HEADER  *FfsHeader,
  IN EFI_PEI_SERVICES     **PeiServices
  )

{
  return EFI_SUCCESS;
}
""",
"""
GLOBAL_REMOVE_IF_UNREFERENCED const UINT32 _gPeimRevision = 0;

EFI_STATUS
${Function} (
  IN EFI_FFS_FILE_HEADER  *FfsHeader,
  IN EFI_PEI_SERVICES     **PeiServices
  );

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_FFS_FILE_HEADER  *FfsHeader,
  IN EFI_PEI_SERVICES     **PeiServices
  )

{
  return ${Function} (FfsHeader, PeiServices);
}
""",
"""
GLOBAL_REMOVE_IF_UNREFERENCED const UINT32 _gPeimRevision = 0;

${BEGIN}
EFI_STATUS
${Function} (
  IN EFI_FFS_FILE_HEADER  *FfsHeader,
  IN EFI_PEI_SERVICES     **PeiServices
  );
${END}

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_FFS_FILE_HEADER  *FfsHeader,
  IN EFI_PEI_SERVICES     **PeiServices
  )

{
  EFI_STATUS  Status;
  EFI_STATUS  CombinedStatus;

  CombinedStatus = EFI_LOAD_ERROR;
${BEGIN}
  Status = ${Function} (FfsHeader, PeiServices);
  if (!EFI_ERROR (Status) || EFI_ERROR (CombinedStatus)) {
    CombinedStatus = Status;
  }
${END}
  return CombinedStatus;
}
"""
]

#
# DXE SMM Entry Point Templates
#
DxeSmmEntryPointString = [
"""
EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )

{
  return EFI_SUCCESS;
}
""",
"""
${BEGIN}
EFI_STATUS
${Function} (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  );
${END}

static BASE_LIBRARY_JUMP_BUFFER  mJumpContext;
static EFI_STATUS  mDriverEntryPointStatus = EFI_LOAD_ERROR;

VOID
EFIAPI
ExitDriver (
  IN EFI_STATUS  Status
  )
{
  if (!EFI_ERROR (Status) || EFI_ERROR (mDriverEntryPointStatus)) {
    mDriverEntryPointStatus = Status;
  }
  LongJump (&mJumpContext, (UINTN)-1);
  ASSERT (FALSE);
}

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )

{
${BEGIN}
  if (SetJump (&mJumpContext) == 0) {
    ExitDriver (${Function} (ImageHandle, SystemTable));
    ASSERT (FALSE);
  }
${END}

  return mDriverEntryPointStatus;
}
"""
]

#
# UEFI Entry Point Templates
#
UefiEntryPointString = [
"""
const UINT32 _gUefiDriverRevision = 0;

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  return EFI_SUCCESS;
}
""",
"""
const UINT32 _gUefiDriverRevision = 0;

EFI_STATUS
${Function} (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  );

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )

{
  return ${Function} (ImageHandle, SystemTable);
}

VOID
EFIAPI
ExitDriver (
  IN EFI_STATUS  Status
  )
{
  if (EFI_ERROR (Status)) {
    ProcessLibraryDestructorList (gImageHandle, gST);
  }
  gBS->Exit (gImageHandle, Status, 0, NULL);
}
""",
"""
const UINT32 _gUefiDriverRevision = 0;

${BEGIN}
EFI_STATUS
${Function} (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  );
${END}

EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )

{
  ${BEGIN}
  if (SetJump (&mJumpContext) == 0) {
    ExitDriver (${Function} (ImageHandle, SystemTable));
    ASSERT (FALSE);
  }
  ${END}
  return mDriverEntryPointStatus;
}

static BASE_LIBRARY_JUMP_BUFFER  mJumpContext;
static EFI_STATUS  mDriverEntryPointStatus = EFI_LOAD_ERROR;

VOID
EFIAPI
ExitDriver (
  IN EFI_STATUS  Status
  )
{
  if (!EFI_ERROR (Status) || EFI_ERROR (mDriverEntryPointStatus)) {
    mDriverEntryPointStatus = Status;
  }
  LongJump (&mJumpContext, (UINTN)-1);
  ASSERT (FALSE);
}
"""
]

#
# UEFI Unload Image Templates
#
UefiUnloadImageString = [
"""
GLOBAL_REMOVE_IF_UNREFERENCED const UINT8 _gDriverUnloadImageCount = ${Count};

EFI_STATUS
EFIAPI
ProcessModuleUnloadList (
  IN EFI_HANDLE        ImageHandle
  )
{
  return EFI_SUCCESS;
}
""",
"""
GLOBAL_REMOVE_IF_UNREFERENCED const UINT8 _gDriverUnloadImageCount = ${Count};

${BEGIN}
EFI_STATUS
${Function} (
  IN EFI_HANDLE        ImageHandle
  );
${END}

EFI_STATUS
EFIAPI
ProcessModuleUnloadList (
  IN EFI_HANDLE        ImageHandle
  )
{
  return ${Function} (ImageHandle);
}
""",
"""
GLOBAL_REMOVE_IF_UNREFERENCED const UINT8 _gDriverUnloadImageCount = ${Count};

${BEGIN}
EFI_STATUS
${Function} (
  IN EFI_HANDLE        ImageHandle
  );
${END}

EFI_STATUS
EFIAPI
ProcessModuleUnloadList (
  IN EFI_HANDLE        ImageHandle
  )
{
  EFI_STATUS  Status;

  Status = EFI_SUCCESS;
${BEGIN}
  if (EFI_ERROR (Status)) {
    ${Function} (ImageHandle);
  } else {
    Status = ${Function} (ImageHandle);
  }
${END}
  return Status;
}
"""
]

#
# Library Constructor and Destructor Templates
#
LibraryString = [
"""
VOID
EFIAPI
ProcessLibrary${Type}List (
  VOID
  )
{
}
""",
"""
VOID
EFIAPI
ProcessLibrary${Type}List (
  IN EFI_FFS_FILE_HEADER       *FfsHeader,
  IN EFI_PEI_SERVICES          **PeiServices
  )
{
}
""",
"""
VOID
EFIAPI
ProcessLibrary${Type}List (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
}
""",
"""
${BEGIN}
RETURN_STATUS
EFIAPI
${Function} (
  VOID
  );
${END}

VOID
EFIAPI
ProcessLibrary${Type}List (
  VOID
  )
{
  EFI_STATUS  Status;

${BEGIN}
  Status = ${Function} ();
  ASSERT_EFI_ERROR (Status);
${END}
}
""",
"""
${BEGIN}
EFI_STATUS
EFIAPI
${Function} (
  IN EFI_FFS_FILE_HEADER       *FfsHeader,
  IN EFI_PEI_SERVICES          **PeiServices
  );
${END}

VOID
EFIAPI
ProcessLibrary${Type}List (
  IN EFI_FFS_FILE_HEADER       *FfsHeader,
  IN EFI_PEI_SERVICES          **PeiServices
  )
{
  EFI_STATUS  Status;

${BEGIN}
  Status = ${Function} (FfsHeader, PeiServices);
  ASSERT_EFI_ERROR (Status);
${END}
}
""",
"""
${BEGIN}
EFI_STATUS
EFIAPI
${Function} (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  );
${END}

VOID
EFIAPI
ProcessLibrary${Type}List (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS  Status;

${BEGIN}
  Status = ${Function} (ImageHandle, SystemTable);
  ASSERT_EFI_ERROR (Status);
${END}
}
"""
]

SpecificationString = """
${BEGIN}
#define ${Specification}
${END}
"""

BasicHeaderFile = "Base.h"

ModuleTypeHeaderFile = {
    "BASE"              :   [BasicHeaderFile],
    "SEC"               :   ["PiPei.h", "Library/DebugLib.h"],
    "PEI_CORE"          :   ["PiPei.h", "Library/DebugLib.h"],  
    "PEIM"              :   ["PiPei.h", "Library/DebugLib.h"],  
    "DXE_CORE"          :   ["PiDxe.h", "Library/DebugLib.h"],  
    "DXE_DRIVER"        :   ["PiDxe.h", "Library/BaseLib.h", "Library/DebugLib.h", "Library/UefiBootServicesTableLib.h"], 
    "DXE_SMM_DRIVER"    :   ["PiDxe.h", "Library/BaseLib.h", "Library/DebugLib.h", "Library/UefiBootServicesTableLib.h"], 
    "DXE_RUNTIME_DRIVER":   ["PiDxe.h", "Library/BaseLib.h", "Library/DebugLib.h", "Library/UefiBootServicesTableLib.h"], 
    "DXE_SAL_DRIVER"    :   ["PiDxe.h", "Library/BaseLib.h", "Library/DebugLib.h", "Library/UefiBootServicesTableLib.h"], 
    "UEFI_DRIVER"       :   ["Uefi.h",  "Library/BaseLib.h", "Library/DebugLib.h", "Library/UefiBootServicesTableLib.h"],
    "UEFI_APPLICATION"  :   ["Uefi.h",  "Library/BaseLib.h", "Library/DebugLib.h", "Library/UefiBootServicesTableLib.h"],
    "USER_DEFINED"      :   [BasicHeaderFile]
}

##ModuleTypeHeaderFile = {
##    "BASE"              :   BasicHeaderFile,
##    "SEC"               :   ["Peim.h", "DebugLib.h", ],         # "PiPei.h",
##    "PEI_CORE"          :   ["PeiCore.h", "DebugLib.h"],        # "PiPei.h",
##    "PEIM"              :   ["Peim.h", "DebugLib.h"],           # PiPei.h",
##    "DXE_CORE"          :   ["DxeCore.h", "DebugLib.h"],        # PiDxe.h",
##    "DXE_DRIVER"        :   ["Dxe.h", "BaseLib.h", "DebugLib.h", "UefiBootServicesTableLib.h"],   # "PiDxe.h",
##    "DXE_SMM_DRIVER"    :   ["Dxe.h", "BaseLib.h", "DebugLib.h", "UefiBootServicesTableLib.h"],   # "PiDxe.h",
##    "DXE_RUNTIME_DRIVER":   ["Dxe.h", "BaseLib.h", "DebugLib.h", "UefiBootServicesTableLib.h"],   # "PiDxe.h",
##    "DXE_SAL_DRIVER"    :   ["Dxe.h", "BaseLib.h", "DebugLib.h", "UefiBootServicesTableLib.h"],   # "PiDxe.h",
##    "UEFI_DRIVER"       :   ["Uefi.h", "BaseLib.h", "DebugLib.h", "UefiBootServicesTableLib.h"],
##    "UEFI_APPLICATION"  :   ["Uefi.h", "BaseLib.h", "DebugLib.h", "UefiBootServicesTableLib.h"]
##}

def GuidStringToGuidStructureString(Guid):
  GuidList = Guid.split('-')
  Result = '{'
  for Index in range(0,3,1):
    Result = Result + '0x' + GuidList[Index] + ', '
  Result = Result + '{0x' + GuidList[3][0:2] + ', 0x' + GuidList[3][2:4]
  for Index in range(0,12,2):
    Result = Result + ', 0x' + GuidList[4][Index:Index+2]
  Result += '}}'
  return Result

def GuidStructureStringToGuidString(GuidValue):
    guidValueString = GuidValue.lower().replace("{", "").replace("}", "").replace(" ", "")
    guidValueList = guidValueString.split(",")
    if len(guidValueList) != 11:
        raise AutoGenError(msg="Invalid GUID value string %s" % GuidValue)
    return "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x" % (
            int(guidValueList[0], 16),
            int(guidValueList[1], 16),
            int(guidValueList[2], 16),
            int(guidValueList[3], 16),
            int(guidValueList[4], 16),
            int(guidValueList[5], 16),
            int(guidValueList[6], 16),
            int(guidValueList[7], 16),
            int(guidValueList[8], 16),
            int(guidValueList[9], 16),
            int(guidValueList[10], 16)
            )

def GuidStructureStringToGuidValueName(GuidValue):
    guidValueString = GuidValue.lower().replace("{", "").replace("}", "").replace(" ", "")
    guidValueList = guidValueString.split(",")
    if len(guidValueList) != 11:
        raise AutoGenError(msg="Invalid GUID value string %s" % GuidValue)
    return "%08x_%04x_%04x_%02x%02x_%02x%02x%02x%02x%02x%02x" % (
            int(guidValueList[0], 16),
            int(guidValueList[1], 16),
            int(guidValueList[2], 16),
            int(guidValueList[3], 16),
            int(guidValueList[4], 16),
            int(guidValueList[5], 16),
            int(guidValueList[6], 16),
            int(guidValueList[7], 16),
            int(guidValueList[8], 16),
            int(guidValueList[9], 16),
            int(guidValueList[10], 16)
            )

def GetGuidValue(packages, cname):
    for p in packages:
        if cname in p.Guids:
            return p.Guids[cname]
        if cname in p.Protocols:
            return p.Protocols[cname]
        if cname in p.Ppis:
            return p.Ppis[cname]
    else:
        raise AutoGenError(msg="Cannot find GUID value for %s in any package" % cname)

class AutoGenString(object):
  def __init__(self):
    self.String = ''

  def Append(self, AppendString, Dictionary=None):
    if Dictionary == None:
      self.String += AppendString
    else:
      while AppendString.find('${BEGIN}') >= 0:
        Start = AppendString.find('${BEGIN}')
        End   = AppendString.find('${END}')
        SubString = AppendString[AppendString.find('${BEGIN}'):AppendString.find('${END}')+6]
        Max = 0
        MaxLen = {}
        for Key in Dictionary:
          if SubString.find('$'+Key) >= 0 or SubString.find('${'+Key+'}') >= 0:
            Value = Dictionary[Key]
            if type(Value) == type([]):
              MaxLen[Key] = len(Value)
            else:
              MaxLen[Key] = 1
            if MaxLen[Key] > Max:
              Max = MaxLen[Key]

        NewString = ''
        for Index in range(0,Max):
          NewDict = {'BEGIN':'','END':''}
          for Key in MaxLen:
            NewDict[Key] = Dictionary[Key]
            if type(Dictionary[Key]) == type([]):
              NewDict[Key] = Dictionary[Key][Index]
          NewString += string.Template(SubString).safe_substitute(NewDict)
        AppendString = AppendString[0:Start] + NewString + AppendString[End+6:]
      NewDict = {}
      for Key in Dictionary:
        NewDict[Key] = Dictionary[Key]
        if type(Dictionary[Key]) == type([]) and len(Dictionary[Key]) > 0:
          NewDict[Key] = Dictionary[Key][0]
      self.String += string.Template(AppendString).safe_substitute(NewDict)

def CreateModulePcdCode(info, autoGenC, autoGenH, pcd):
    pcdTokenNumber = info.PlatformInfo.PcdTokenNumber
    #
    # Write PCDs
    #
    pcdTokenName = '_PCD_TOKEN_' + pcd.TokenCName
    if pcd.Type in gDynamicExPcd:
        tokenNumber = pcd.TokenValue
    else:
        tokenNumber = pcdTokenNumber[pcd.TokenCName, pcd.TokenSpaceGuidCName]
    autoGenH.Append('#define %s  %d\n' % (pcdTokenName, tokenNumber))

    EdkLogger.debug(EdkLogger.DEBUG_3, "Creating code for " + pcd.TokenCName + "/" + pcd.TokenSpaceGuidCName)
    if pcd.Type not in ItemTypeStringDatabase:
        raise AutoGenError(msg="Unknown PCD type [%s] of PCD %s/%s" % (pcd.Type, pcd.TokenCName, pcd.TokenSpaceGuidCName))
    if pcd.DatumType not in DatumSizeStringDatabase:
        raise AutoGenError(msg="Unknown datum type [%s] of PCD %s/%s" % (pcd.DatumType, pcd.TokenCName, pcd.TokenSpaceGuidCName))

    datumSize = DatumSizeStringDatabase[pcd.DatumType]
    datumSizeLib = DatumSizeStringDatabaseLib[pcd.DatumType]
    getModeName = '_PCD_GET_MODE_' + DatumSizeStringDatabaseH[pcd.DatumType] + '_' + pcd.TokenCName
    setModeName = '_PCD_SET_MODE_' + DatumSizeStringDatabaseH[pcd.DatumType] + '_' + pcd.TokenCName

    if pcd.Type in gDynamicExPcd:
        autoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\n' % (getModeName, datumSizeLib, pcd.TokenSpaceGuidCName, pcdTokenName))
        if DatumType == 'VOID*':
            autoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\n' % (setModeName, datumSizeLib, pcd.TokenSpaceGuidCName, pcdTokenName))
        else:
            autoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\n' % (setModeName, datumSizeLib, pcd.TokenSpaceGuidCName, pcdTokenName))
    elif pcd.Type in gDynamicPcd:
        autoGenH.Append('#define %s  LibPcdGet%s(%s)\n' % (getModeName, datumSizeLib, pcdTokenName))
        if pcd.DatumType == 'VOID*':
            autoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\n' %(setModeName, datumSizeLib, pcdTokenName))
        else:
            autoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\n' % (setModeName, datumSizeLib, pcdTokenName))
    else:
        PcdVariableName = '_gPcd_' + ItemTypeStringDatabase[pcd.Type] + '_' + pcd.TokenCName
        Const = 'const'
        if pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:
            Const = ''
        Type = ''
        Array = ''
        Value = pcd.DefaultValue
        if pcd.DatumType == 'UINT64':
            Value += 'ULL'
        if pcd.DatumType == 'VOID*':
            ArraySize = int(pcd.MaxDatumSize)
            if Value[0] == '{':
                Type = '(VOID *)'
            else:
                Unicode = False
                if Value[0] == 'L':
                    Unicode = True
                Value = Value.lstrip('L').strip('"')
                NewValue = '{'
                for Index in range(0,len(Value)):
                    NewValue = NewValue + str(ord(Value[Index]) % 0x100) + ', '
                    if Unicode:
                        NewValue = NewValue + str(ord(Value[Index]) / 0x100) + ', '
                if Unicode:
                    if ArraySize < (len(Value)*2 + 2):
                        ArraySize = len(Value)*2 + 2
                    NewValue = NewValue + '0, '
                else:
                    if ArraySize < (len(Value) + 1):
                        ArraySize = len(Value) + 1
                Value = NewValue + '0 }'
            Array = '[%d]' % ArraySize

        PcdValueName = '_PCD_VALUE_' + pcd.TokenCName
        if pcd.DatumType == 'VOID*' and Value[0] == '{':
            autoGenH.Append('#define _PCD_PATCHABLE_%s_SIZE %s\n' % (pcd.TokenCName, pcd.MaxDatumSize))
            autoGenH.Append('#define %s  %s%s\n' %(PcdValueName, Type, PcdVariableName))
            autoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT8 %s%s = %s;\n' % (Const, PcdVariableName, Array, Value))
            autoGenH.Append('extern %s UINT8 %s%s;\n' %(Const, PcdVariableName, Array))
            autoGenH.Append('#define %s  %s%s\n' %(getModeName, Type, PcdVariableName))
        else:
            autoGenH.Append('#define %s  %s\n' %(PcdValueName, Value))
            autoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s %s = %s;\n' %(Const, pcd.DatumType, PcdVariableName, PcdValueName))
            autoGenH.Append('extern %s  %s  %s%s;\n' % (Const, pcd.DatumType, PcdVariableName, Array))
            autoGenH.Append('#define %s  %s%s\n' % (getModeName, Type, PcdVariableName))

        if pcd.Type == 'PATCHABLE_IN_MODULE':
            if pcd.DatumType == 'VOID*':
                autoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtr(_gPcd_BinaryPatch_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\n' % (setModeName, pcd.TokenCName, pcd.TokenCName))
            else:
                autoGenH.Append('#define %s(Value)  (%s = (Value))\n' % (setModeName, PcdVariableName))
        else:
            autoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\n' % setModeName)

def CreateLibraryPcdCode(info, autoGenC, autoGenH, pcd):
    pcdTokenNumber = info.PlatformInfo.PcdTokenNumber
    tokenSpaceGuidCName = pcd.TokenSpaceGuidCName
    tokenCName  = pcd.TokenCName
    tokenNumber = pcdTokenNumber[tokenCName, tokenSpaceGuidCName]
    
    if pcd.Type not in ItemTypeStringDatabase:
        raise AutoGenError(msg="Unknown PCD type [%s] of PCD %s/%s" % (pcd.Type, pcd.TokenCName, pcd.TokenSpaceGuidCName))
    if pcd.DatumType not in DatumSizeStringDatabase:
        raise AutoGenError(msg="Unknown datum type [%s] of PCD %s/%s" % (pcd.DatumType, pcd.TokenCName, pcd.TokenSpaceGuidCName))

    datumType   = pcd.DatumType
    datumSize   = DatumSizeStringDatabaseH[datumType]
    datumSizeLib= DatumSizeStringDatabaseLib[datumType]
    getModeName = '_PCD_GET_MODE_' + datumSize + '_' + tokenCName
    setModeName = '_PCD_SET_MODE_' + datumSize + '_' + tokenCName

    type = ''
    array = ''
    if pcd.DatumType == 'VOID*':
        type = '(VOID *)'
        array = '[]'

    autoGenH.Append('#define _PCD_TOKEN_%s  %d\n' % (tokenCName, tokenNumber))

    pcdItemType = pcd.Type
    if pcdItemType in gDynamicPcd:
        pcdItemType = TAB_PCDS_FIXED_AT_BUILD
        if (tokenCName, tokenSpaceGuidCName) in info.PlatformInfo.Platform.Pcds:
            pcdItemType  = info.PlatformInfo.Platform.Pcds[tokenCName, tokenSpaceGuidCName].Type
    if pcdItemType in gDynamicExPcd:
        pcdTokenName = '_PCD_TOKEN_' + tokenCName
        autoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\n' % (getModeName, datumSizeLib, tokenSpaceGuidCName, pcdTokenName))
        if DatumType == 'VOID*':
            autoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\n' % (setModeName,datumSizeLib, tokenSpaceGuidCName, pcdTokenName))
        else:
            autoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\n' % (setModeName, datumSizeLib, tokenSpaceGuidCName, pcdTokenName))
    if pcdItemType in gDynamicPcd:
        pcdTokenName = '_PCD_TOKEN_' + tokenCName
        autoGenH.Append('#define %s  LibPcdGet%s(%s)\n' % (getModeName, datumSizeLib, pcdTokenName))
        if datumType == 'VOID*':
            autoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\n' %(setModeName, datumSizeLib, pcdTokenName))
        else:
            autoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\n' % (setModeName, datumSizeLib, pcdTokenName))
    if pcdItemType == TAB_PCDS_PATCHABLE_IN_MODULE:
        pcdVariableName = '_gPcd_' + ItemTypeStringDatabase[TAB_PCDS_PATCHABLE_IN_MODULE] + '_' + tokenCName
        autoGenH.Append('extern %s _gPcd_BinaryPatch_%s%s;\n' %(datumType, tokenCName, array) )
        autoGenH.Append('#define %s  %s_gPcd_BinaryPatch_%s\n' %(getModeName, type, tokenCName))
        autoGenH.Append('#define %s(Value)  (%s = (Value))\n' % (setModeName, pcdVariableName))
    if pcdItemType == TAB_PCDS_FIXED_AT_BUILD or pcdItemType == TAB_PCDS_FEATURE_FLAG:
        autoGenH.Append('extern const %s _gPcd_FixedAtBuild_%s%s;\n' %(datumType, tokenCName, array))
        autoGenH.Append('#define %s  %s_gPcd_FixedAtBuild_%s\n' %(getModeName, type, tokenCName))
        autoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\n' % setModeName)

def CreatePcdDatabasePhaseSpecificAutoGen (platform, phase):
    AutoGenC = AutoGenString()
    AutoGenH = AutoGenString()

    Dict = {
        'PHASE'                         : phase,
        'GUID_TABLE_SIZE'               : '1',
        'STRING_TABLE_SIZE'             : '1',
        'SKUID_TABLE_SIZE'              : '1',
        'LOCAL_TOKEN_NUMBER_TABLE_SIZE' : '1',
        'LOCAL_TOKEN_NUMBER'            : '0',
        'EXMAPPING_TABLE_SIZE'          : '1',
        'EX_TOKEN_NUMBER'               : '0',
        'SIZE_TABLE_SIZE'               : '2',
        'GUID_TABLE_EMPTY'              : 'TRUE',
        'STRING_TABLE_EMPTY'            : 'TRUE',
        'SKUID_TABLE_EMPTY'             : 'TRUE',
        'DATABASE_EMPTY'                : 'TRUE',
        'EXMAP_TABLE_EMPTY'             : 'TRUE',
        'PCD_DATABASE_UNINIT_EMPTY'     : '  UINT8  dummy; /* PCD_DATABASE_UNINIT is emptry */',
        'SYSTEM_SKU_ID'                 : '  SKU_ID             SystemSkuId;',
        'SYSTEM_SKU_ID_VALUE'           : '0'
    }

    for DatumType in ['UINT64','UINT32','UINT16','UINT8','BOOLEAN']:
        Dict['VARDEF_CNAME_' + DatumType] = []
        Dict['VARDEF_GUID_' + DatumType]  = []
        Dict['VARDEF_SKUID_' + DatumType] = []
        Dict['VARDEF_VALUE_' + DatumType] = []
        for Init in ['INIT','UNINIT']:
            Dict[Init+'_CNAME_DECL_' + DatumType]   = []
            Dict[Init+'_GUID_DECL_' + DatumType]    = []
            Dict[Init+'_NUMSKUS_DECL_' + DatumType] = []
            Dict[Init+'_VALUE_' + DatumType]        = []

    for Type in ['STRING_HEAD','VPD_HEAD','VARIABLE_HEAD']:
        Dict[Type + '_CNAME_DECL']   = []
        Dict[Type + '_GUID_DECL']    = []
        Dict[Type + '_NUMSKUS_DECL'] = []
        Dict[Type + '_VALUE'] = []

    Dict['STRING_TABLE_INDEX'] = []
    Dict['STRING_TABLE_LENGTH']  = []
    Dict['STRING_TABLE_CNAME'] = []
    Dict['STRING_TABLE_GUID']  = []
    Dict['STRING_TABLE_VALUE'] = []

    Dict['SIZE_TABLE_CNAME'] = []
    Dict['SIZE_TABLE_GUID']  = []
    Dict['SIZE_TABLE_CURRENT_LENGTH']  = []
    Dict['SIZE_TABLE_MAXIMUM_LENGTH']  = []

    Dict['EXMAPPING_TABLE_EXTOKEN'] = []
    Dict['EXMAPPING_TABLE_LOCAL_TOKEN'] = []
    Dict['EXMAPPING_TABLE_GUID_INDEX'] = []

    Dict['GUID_STRUCTURE'] = []

    Dict['SKUID_VALUE'] = []

    if phase == 'DXE':
        Dict['SYSTEM_SKU_ID'] = ''
        Dict['SYSTEM_SKU_ID_VALUE'] = ''

    StringTableIndex = 0
    StringTableSize = 0
    NumberOfLocalTokens = 0
    NumberOfPeiLocalTokens = 0
    NumberOfDxeLocalTokens = 0
    NumberOfExTokens = 0
    NumberOfSizeItems = 0
    GuidList = []

    for Pcd in platform.DynamicPcdList:
        CName = Pcd.TokenCName
        TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName
        EdkLogger.debug(EdkLogger.DEBUG_3, "PCD: %s %s (%s : %s)" % (CName, TokenSpaceGuidCName, Pcd.Phase, phase))

        if Pcd.Phase == 'PEI':
            NumberOfPeiLocalTokens += 1
        if Pcd.Phase == 'DXE':
            NumberOfDxeLocalTokens += 1
        if Pcd.Phase != phase:
            continue

        #
        # TODO: need GetGuidValue() definition
        #
        TokenSpaceGuid = GuidStructureStringToGuidValueName(GetGuidValue(platform.PackageList, TokenSpaceGuidCName))
        if Pcd.Type == 'DYNAMIC_EX':
            if TokenSpaceGuid not in GuidList:
                GuidList += [TokenSpaceGuid]
                Dict['GUID_STRUCTURE'].append(TokenSpaceGuid)
            NumberOfExTokens += 1

        ValueList = []
        StringHeadOffsetList = []
        VpdHeadOffsetList = []
        VariableHeadValueList = []
        Pcd.InitString = 'UNINIT'

        if Pcd.DatumType == 'VOID*':
            Pcd.TokenTypeList = ['PCD_DATUM_TYPE_POINTER']
        elif Pcd.DatumType == 'BOOLEAN':
            Pcd.TokenTypeList = ['PCD_DATUM_TYPE_UINT8']
        else:
            Pcd.TokenTypeList = ['PCD_DATUM_TYPE_' + Pcd.DatumType]

        if len(Pcd.SkuInfoList) > 1:
            Pcd.TokenTypeList += ['PCD_TYPE_SKU_ENABLED']

        for Sku in Pcd.SkuInfoList:
            SkuId = Sku.SkuId
            if SkuId == None or SkuId == '':
                continue

            if SkuId not in Dict['SKUID_VALUE']:
                Dict['SKUID_VALUE'].append(SkuId)

            SkuIdIndex =   Dict['SKUID_VALUE'].index(SkuId)
            if len(Sku.VariableName) > 0:
                Pcd.TokenTypeList += ['PCD_TYPE_HII']
                Pcd.InitString = 'INIT'
                VariableNameStructure = '{' + ', '.join(Sku.VariableName) + ', 0x0000}'
                if VariableNameStructure not in Dict['STRING_TABLE_VALUE']:
                    Dict['STRING_TABLE_CNAME'].append(CName)
                    Dict['STRING_TABLE_GUID'].append(TokenSpaceGuid)
                    if StringTableIndex == 0:
                        Dict['STRING_TABLE_INDEX'].append('')
                    else:
                        Dict['STRING_TABLE_INDEX'].append('_%d' % StringTableIndex)

                    Dict['STRING_TABLE_LENGTH'].append(len(Sku.VariableName) + 1)
                    Dict['STRING_TABLE_VALUE'].append(VariableNameStructure)
                    StringTableIndex += 1
                    StringTableSize += len(Sku.VariableName) + 1

                VariableHeadStringIndex = 0
                for Index in range(Dict['STRING_TABLE_VALUE'].index(VariableNameStructure)):
                    VariableHeadStringIndex += Dict['STRING_TABLE_LENGTH'][Index]

                VariableGuid = GuidStructureStringToGuidValueName(self.GetGuidValue(Sku.VariableGuid))
                if VariableGuid not in GuidList:
                    GuidList += [VariableGuid]
                    Dict['GUID_STRUCTURE'].append(VariableGuid)
                VariableHeadGuidIndex = GuidList.index(VariableGuid)

                VariableHeadValueList.append('%d, %d, %s, offsetof(${PHASE}_PCD_DATABASE, Init.%s_%s_VariableDefault_%s)' %
                                             (VariableHeadGuidIndex, VariableHeadStringIndex, Sku.VariableOffset, CName, TokenSpaceGuid, SkuIdIndex))
                Dict['VARDEF_CNAME_'+Pcd.DatumType].append(CName)
                Dict['VARDEF_GUID_'+Pcd.DatumType].append(TokenSpaceGuid)
                Dict['VARDEF_SKUID_'+Pcd.DatumType].append(SkuIdIndex)
                Dict['VARDEF_VALUE_'+Pcd.DatumType].append(Sku.HiiDefaultValue)
            elif Sku.VpdOffset != '':
                Pcd.TokenTypeList += ['PCD_TYPE_VPD']
                Pcd.InitString = 'INIT'
                VpdHeadOffsetList.append(Sku.VpdOffset)
            else:
                if Pcd.DatumType == 'VOID*':
                    Pcd.TokenTypeList += ['PCD_TYPE_STRING']
                    Pcd.InitString = 'INIT'
                    if Sku.DefaultValue != '':
                        NumberOfSizeItems += 1
                        Dict['STRING_TABLE_CNAME'].append(CName)
                        Dict['STRING_TABLE_GUID'].append(TokenSpaceGuid)

                        if StringTableIndex == 0:
                            Dict['STRING_TABLE_INDEX'].append('')
                        else:
                            Dict['STRING_TABLE_INDEX'].append('_%d' % StringTableIndex)
                        if Sku.DefaultValue[0] == 'L':
                            Size = len(Sku.DefaultValue) - 3
                            Dict['STRING_TABLE_VALUE'].append(Sku.DefaultValue)
                        elif Sku.DefaultValue[0] == '"':
                            Size = len(Sku.DefaultValue) - 2
                            Dict['STRING_TABLE_VALUE'].append(Sku.DefaultValue)
                        elif Sku.DefaultValue[0] == '{':
                            Size = len(Sku.DefaultValue.replace(',',' ').split())
                            Dict['STRING_TABLE_VALUE'].append('{' + Sku.DefaultValue + '}')

                        StringHeadOffsetList.append(str(StringTableSize))
                        Dict['SIZE_TABLE_CNAME'].append(CName)
                        Dict['SIZE_TABLE_GUID'].append(TokenSpaceGuid)
                        Dict['SIZE_TABLE_CURRENT_LENGTH'].append(Size)
                        Dict['SIZE_TABLE_MAXIMUM_LENGTH'].append(Pcd.MaxDatumSize)
                        if Pcd.MaxDatumSize != '' and Pcd.MaxDatumSize > Size:
                            Size = int(Pcd.MaxDatumSize)
                        Dict['STRING_TABLE_LENGTH'].append(Size)
                        StringTableIndex += 1
                        StringTableSize += Size
                else:
                    Pcd.TokenTypeList += ['PCD_TYPE_DATA']
                    if Sku.DefaultValue == 'TRUE':
                        Pcd.InitString = 'INIT'
                    elif Sku.DefaultValue.find('0x') == 0:
                        if int(Sku.DefaultValue,16) != 0:
                            Pcd.InitString = 'INIT'
                    elif Sku.DefaultValue[0].isdigit():
                        if int(Sku.DefaultValue) != 0:
                            Pcd.InitString = 'INIT'
                    ValueList.append(Sku.DefaultValue)

        Pcd.TokenTypeList = list(set(Pcd.TokenTypeList))
        if 'PCD_TYPE_HII' in Pcd.TokenTypeList:
            Dict['VARIABLE_HEAD_CNAME_DECL'].append(CName)
            Dict['VARIABLE_HEAD_GUID_DECL'].append(TokenSpaceGuid)
            Dict['VARIABLE_HEAD_NUMSKUS_DECL'].append(len(Pcd.SkuInfoList))
            Dict['VARIABLE_HEAD_VALUE'].append('{ %s }\n' % ' },\n    { '.join(VariableHeadValueList))
        if 'PCD_TYPE_VPD' in Pcd.TokenTypeList:
            Dict['VPD_HEAD_CNAME_DECL'].append(CName)
            Dict['VPD_HEAD_GUID_DECL'].append(TokenSpaceGuid)
            Dict['VPD_HEAD_NUMSKUS_DECL'].append(len(Pcd.SkuInfoList))
            Dict['VPD_HEAD_VALUE'].append('{ %s }' % ' }, { '.join(VpdHeadOffsetList))
        if 'PCD_TYPE_STRING' in Pcd.TokenTypeList:
            Dict['STRING_HEAD_CNAME_DECL'].append(CName)
            Dict['STRING_HEAD_GUID_DECL'].append(TokenSpaceGuid)
            Dict['STRING_HEAD_NUMSKUS_DECL'].append(len(Pcd.SkuInfoList))
            Dict['STRING_HEAD_VALUE'].append(', '.join(StringHeadOffsetList))
        if 'PCD_TYPE_DATA' in Pcd.TokenTypeList:
            Dict[Pcd.InitString+'_CNAME_DECL_'+Pcd.DatumType].append(CName)
            Dict[Pcd.InitString+'_GUID_DECL_'+Pcd.DatumType].append(TokenSpaceGuid)
            Dict[Pcd.InitString+'_NUMSKUS_DECL_'+Pcd.DatumType].append(len(Pcd.SkuInfoList))
            if Pcd.InitString == 'UNINIT':
                Dict['PCD_DATABASE_UNINIT_EMPTY'] = ''
            else:
                Dict[Pcd.InitString+'_VALUE_'+Pcd.DatumType].append(', '.join(ValueList))

    if phase == 'PEI':
        NumberOfLocalTokens = NumberOfPeiLocalTokens
    if phase == 'DXE':
        NumberOfLocalTokens = NumberOfDxeLocalTokens

    Dict['TOKEN_INIT']       = ['' for x in range(NumberOfLocalTokens)]
    Dict['TOKEN_CNAME']      = ['' for x in range(NumberOfLocalTokens)]
    Dict['TOKEN_GUID']       = ['' for x in range(NumberOfLocalTokens)]
    Dict['TOKEN_TYPE']       = ['' for x in range(NumberOfLocalTokens)]

    for Pcd in platform.DynamicPcdList:
        CName = Pcd.TokenCName
        TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName
        if Pcd.Phase != phase:
            continue

        TokenSpaceGuid = GuidStructureStringToGuidValueName(GetGuidValue(platform.PackageList, TokenSpaceGuidCName))
        GeneratedTokenNumber = platform.PcdTokenNumber[CName, TokenSpaceGuidCName] - 1
        if phase == 'DXE':
            GeneratedTokenNumber -= NumberOfPeiLocalTokens

        EdkLogger.debug(EdkLogger.DEBUG_1, "PCD = %s / %s" % (CName, TokenSpaceGuidCName))
        EdkLogger.debug(EdkLogger.DEBUG_1, "phase = %s" % phase)
        EdkLogger.debug(EdkLogger.DEBUG_1, "GeneratedTokenNumber = %s" % str(GeneratedTokenNumber))

        Dict['TOKEN_INIT'][GeneratedTokenNumber] = 'Init'
        if Pcd.InitString == 'UNINIT':
            Dict['TOKEN_INIT'][GeneratedTokenNumber] = 'Uninit'
        Dict['TOKEN_CNAME'][GeneratedTokenNumber] = CName
        Dict['TOKEN_GUID'][GeneratedTokenNumber] = TokenSpaceGuid
        Dict['TOKEN_TYPE'][GeneratedTokenNumber] = ' | '.join(Pcd.TokenTypeList)
        if Pcd.Type == 'DYNAMIC_EX':
            Dict['EXMAPPING_TABLE_EXTOKEN'].append(Pcd.Token)
            Dict['EXMAPPING_TABLE_LOCAL_TOKEN'].append(GeneratedTokenNumber)
            Dict['EXMAPPING_TABLE_GUID_INDEX'].append(GuidList.index(TokenSpaceGuid))

    if GuidList != []:
        Dict['GUID_TABLE_EMPTY'] = 'FALSE'
        Dict['GUID_TABLE_SIZE'] = len(GuidList)
    else:
        Dict['GUID_STRUCTURE'] = [GuidStringToGuidStructureString('00000000-0000-0000-0000-000000000000')]

    if StringTableIndex == 0:
        Dict['STRING_TABLE_INDEX'].append('')
        Dict['STRING_TABLE_LENGTH'].append(1)
        Dict['STRING_TABLE_CNAME'].append('')
        Dict['STRING_TABLE_GUID'].append('')
        Dict['STRING_TABLE_VALUE'].append('{ 0 }')
    else:
        Dict['STRING_TABLE_EMPTY'] = 'FALSE'
        Dict['STRING_TABLE_SIZE'] = StringTableSize

    if Dict['SIZE_TABLE_CNAME'] == []:
        Dict['SIZE_TABLE_CNAME'].append('')
        Dict['SIZE_TABLE_GUID'].append('')
        Dict['SIZE_TABLE_CURRENT_LENGTH'].append(0)
        Dict['SIZE_TABLE_MAXIMUM_LENGTH'].append(0)

    if NumberOfLocalTokens != 0:
        Dict['DATABASE_EMPTY']                = 'FALSE'
        Dict['LOCAL_TOKEN_NUMBER_TABLE_SIZE'] = NumberOfLocalTokens
        Dict['LOCAL_TOKEN_NUMBER']            = NumberOfLocalTokens

    if NumberOfExTokens != 0:
        Dict['EXMAP_TABLE_EMPTY']    = 'FALSE'
        Dict['EXMAPPING_TABLE_SIZE'] = NumberOfExTokens
        Dict['EX_TOKEN_NUMBER']      = NumberOfExTokens
    else:
        Dict['EXMAPPING_TABLE_EXTOKEN'].append(0)
        Dict['EXMAPPING_TABLE_LOCAL_TOKEN'].append(0)
        Dict['EXMAPPING_TABLE_GUID_INDEX'].append(0)

    if NumberOfSizeItems != 0:
        Dict['SIZE_TABLE_SIZE'] = NumberOfSizeItems * 2

    AutoGenH.Append(PcdDatabaseAutoGenH, Dict)
    if NumberOfLocalTokens == 0:
        AutoGenC.Append(EmptyPcdDatabaseAutoGenC, Dict)
    else:
        AutoGenC.Append(PcdDatabaseAutoGenC, Dict)

    return AutoGenH, AutoGenC

def CreatePcdDatabaseCode (info, autoGenC, autoGenH):
    if info.PcdIsDriver == "":
        return
    autoGenH.Append(PcdDatabaseCommonAutoGenH)
    additionalAutoGenH, additionalAutoGenC = CreatePcdDatabasePhaseSpecificAutoGen (info.PlatformInfo, 'PEI')
    autoGenH.Append(additionalAutoGenH.String)

    phase = PcdPhaseMap[info.PcdIsDriver]
    if phase == 'PEI':
        autoGenC.Append(additionalAutoGenC.String)

    if phase == 'DXE':
        additionalAutoGenH, additionalAutoGenC = CreatePcdDatabasePhaseSpecificAutoGen (info.PlatformInfo, phase)
        autoGenH.Append(additionalAutoGenH.String)
        autoGenC.Append(additionalAutoGenC.String)
        autoGenH.Append(PcdDatabaseEpilogueAutoGenH)

def CreateLibraryConstructorCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        return
    #
    # Library Constructors
    #
    ConstructorList = []
    for lib in info.DependentLibraryList:
        if len(lib.ConstructorList) <= 0:
            continue
        ConstructorList.extend(lib.ConstructorList)

    Dict = {'Type':'Constructor', 'Function':ConstructorList}
    if info.ModuleType == 'BASE':
        if len(ConstructorList) == 0:
            autoGenC.Append(LibraryString[0], Dict)
        else:
            autoGenC.Append(LibraryString[3], Dict)
    elif info.ModuleType in ['PEI_CORE','PEIM']:
        if len(ConstructorList) == 0:
            autoGenC.Append(LibraryString[1], Dict)
        else:
            autoGenC.Append(LibraryString[4], Dict)
    elif info.ModuleType in ['DXE_CORE','DXE_DRIVER','DXE_SMM_DRIVER','DXE_RUNTIME_DRIVER','DXE_SAL_DRIVER','UEFI_DRIVER','UEFI_APPLICATION']:
        if len(ConstructorList) == 0:
            autoGenC.Append(LibraryString[2], Dict)
        else:
            autoGenC.Append(LibraryString[5], Dict)

def CreateLibraryDestructorCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        return
    #
    # Library Destructors
    #
    DestructorList = []
    for lib in info.DependentLibraryList:
        if len(lib.DestructorList) <= 0:
            continue
        DestructorList.extend(lib.DestructorList)

    DestructorList.reverse()
    if info.ModuleType in ['DXE_CORE','DXE_DRIVER','DXE_SMM_DRIVER','DXE_RUNTIME_DRIVER','DXE_SAL_DRIVER','UEFI_DRIVER','UEFI_APPLICATION']:
        if len(DestructorList) == 0:
            autoGenC.Append(LibraryString[2], {'Type':'Destructor','Function':DestructorList})
        else:
            autoGenC.Append(LibraryString[5], {'Type':'Destructor','Function':DestructorList})


def CreateModuleEntryPointCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        return
    #
    # Module Entry Points
    #
    NumEntryPoints = len(info.Module.ModuleEntryPointList)
    Dict = {'Function':info.Module.ModuleEntryPointList}

    if info.ModuleType in ['PEI_CORE', 'DXE_CORE']:
        if NumEntryPoints != 1:
            raise AutoGenError(msg='%s must have exactly one entry point' % info.ModuleType)
    if info.ModuleType == 'PEI_CORE':
        autoGenC.Append(PeiCoreEntryPointString, Dict)
    elif info.ModuleType == 'DXE_CORE':
        autoGenC.Append(DxeCoreEntryPointString, Dict)
    elif info.ModuleType == 'PEIM':
        if NumEntryPoints < 2:
            autoGenC.Append(PeimEntryPointString[NumEntryPoints], Dict)
        else:
            autoGenC.Append(PeimEntryPointString[2], Dict)
    elif info.ModuleType in ['DXE_RUNTIME_DRIVER','DXE_DRIVER','DXE_SMM_DRIVER', 'DXE_SAL_DRIVER','UEFI_DRIVER','UEFI_APPLICATION']:
        if info.ModuleType == 'DXE_SMM_DRIVER':
            if NumEntryPoints == 0:
                autoGenC.Append(DxeSmmEntryPointString[0], Dict)
            else:
                autoGenC.Append(DxeSmmEntryPointString[1], Dict)
        else:
            if NumEntryPoints < 2:
                autoGenC.Append(UefiEntryPointString[NumEntryPoints], Dict)
            else:
                autoGenC.Append(UefiEntryPointString[2], Dict)

def CreateModuleUnloadImageCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        return
    #
    # Unload Image Handlers
    #
    NumUnloadImage = len(info.Module.ModuleUnloadImageList)
    Dict = {'Count':NumUnloadImage, 'Function':info.Module.ModuleUnloadImageList}
    if NumUnloadImage < 2:
        autoGenC.Append(UefiUnloadImageString[NumUnloadImage], Dict)
    else:
        autoGenC.Append(UefiUnloadImageString[2], Dict)

def CreateGuidDefinitionCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        return
    #
    # GUIDs
    #
    for Key in info.GuidList:
        autoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED EFI_GUID  %s = %s;\n' % (Key, info.GuidList[Key]))

def CreateProtocolDefinitionCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        return
    #
    # Protocol GUIDs
    #
    for Key in info.ProtocolList:
        autoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED EFI_GUID  %s = %s;\n' % (Key, info.ProtocolList[Key]))

def CreatePpiDefinitionCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        return
    #
    # PPI GUIDs
    #
    for Key in info.PpiList:
        autoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED EFI_GUID  %s = %s;\n' % (Key, info.PpiList[Key]))

def CreatePcdCode(info, autoGenC, autoGenH):
    if info.IsLibrary:
        for pcd in info.PcdList:
            CreateLibraryPcdCode(info, autoGenC, autoGenH, pcd)
    else:
        for pcd in info.PcdList:
            CreateModulePcdCode(info, autoGenC, autoGenH, pcd)
    CreatePcdDatabaseCode(info, autoGenC, autoGenH)

def CreateUnicodeStringCode(info, autoGenC, autoGenH):
    if len(info.UnicodeFileList) == 0:
        return

    cwd = os.getcwd()
    os.chdir(info.WorkspaceDir)

    incList = [os.path.join(info.WorkspaceDir, inc) for inc in info.IncludePathList]
    hCode, cCode = GetStringFiles(info.UnicodeFileList, incList, [], info.Name)
    autoGenC.Append("\n//\n//Unicode String Pack Definition\n//\n")
    autoGenC.Append(cCode)
    autoGenC.Append("\n")
    autoGenH.Append("\n//\n//Unicode String ID\n//\n")
    autoGenH.Append(hCode)
    autoGenH.Append("\n#define STRING_ARRAY_NAME %sStrings\n" % info.Name)
    os.chdir(cwd)

def CreateHeaderCode(info, autoGenC, autoGenH):
    # file header
    autoGenH.Append(AutoGenHeaderString,   {'FileName':'AutoGen.h'})
    # header file Prologue
    autoGenH.Append(AutoGenHPrologueString,{'Guid':info.Guid.replace('-','_')})
    # specification macros
    autoGenH.Append(SpecificationString,   {'Specification':info.MacroList})
    # header files includes
    autoGenH.Append("#include <%s>\n" % BasicHeaderFile)

    if info.IsLibrary:
        return

    # C file header
    autoGenC.Append(AutoGenHeaderString, {'FileName':'AutoGen.c'})
    # C file header files includes
    for inc in ModuleTypeHeaderFile[info.ModuleType]:
        autoGenC.Append("#include <%s>\n" % inc)

    #
    # Publish the CallerId Guid
    #
    if info.ModuleType == 'BASE':
        autoGenC.Append('\nGLOBAL_REMOVE_IF_UNREFERENCED GUID  gEfiCallerIdGuid = %s;\n' % GuidStringToGuidStructureString(info.Guid))
    else:
        autoGenC.Append('\nGLOBAL_REMOVE_IF_UNREFERENCED EFI_GUID  gEfiCallerIdGuid = %s;\n' % GuidStringToGuidStructureString(info.Guid))

def CreateFooterCode(info, autoGenC, autoGenH):
    autoGenH.Append(AutoGenHEpilogueString)

def CreateCode(info, autoGenC, autoGenH):
    CreateHeaderCode(info, autoGenC, autoGenH)

    CreateLibraryConstructorCode(info, autoGenC, autoGenH)
    CreateLibraryDestructorCode(info, autoGenC, autoGenH)
    CreateModuleEntryPointCode(info, autoGenC, autoGenH)
    CreateModuleUnloadImageCode(info, autoGenC, autoGenH)
    CreateGuidDefinitionCode(info, autoGenC, autoGenH)
    CreateProtocolDefinitionCode(info, autoGenC, autoGenH)
    CreatePpiDefinitionCode(info, autoGenC, autoGenH)
    CreatePcdCode(info, autoGenC, autoGenH)
    CreateUnicodeStringCode(info, autoGenC, autoGenH)

    CreateFooterCode(info, autoGenC, autoGenH)

def Generate(filePath, autoGenC, autoGenH):
    CreateDirectory(filePath)

    autoGenFileList = []
    SaveFile(os.path.join(filePath, "AutoGen.h"), autoGenH.String)
    autoGenFileList.append("AutoGen.h")

    if autoGenC.String != "":
        SaveFile(os.path.join(filePath, "AutoGen.c"), autoGenC.String)
        autoGenFileList.append("AutoGen.c")

    return autoGenFileList

def SaveFile(file, content):
    f = None
    if os.path.exists(file):
        f = open(file, "r")
        if content == f.read():
            f.close()
            return
        f.close()
    f = open(file, "w")
    f.write(content)
    f.close()
