#!/usr/bin/env python

"""Create GNU Makefiles for the Libraries of the MdePkg."""

import os, sys, imp, getopt, string, xml.dom.minidom, shutil
import os.path as path
from SequentialDict import *
from EdkIIWorkspaceBuild import *
from EdkIIWorkspace import *

Rule = None

MakefileHeader = '''#
# DO NOT EDIT
# This file is auto-generated by build utility
#
# Module Name:
#
#   %(MAKEFILE_NAME)s
#
# Abstract:
#
#   Auto-generated makefile for building module and libraries
#
'''

MakeType = ""
if sys.platform == "win32":
    MakeType = "nmake"
else:
    MakeType = "gmake"

MakefileName = {"nmake" : "makefile", "gmake" : "GNUmakefile"}

OutputFlag = {
    ("MSFT", "CC", "OUTPUT")      :   "/Fo",
    ("MSFT", "SLINK", "OUTPUT")   :   "/OUT:",
    ("MSFT", "DLINK", "OUTPUT")   :   "/OUT:",
    ("MSFT", "ASMLINK", "OUTPUT") :   "/OUT:",
    ("MSFT", "PCH", "OUTPUT")     :   "/Fp",
    ("MSFT", "ASM", "OUTPUT")     :   "/Fo",
    
    ("INTEL", "CC", "OUTPUT")          :   "/Fo",
    ("INTEL", "SLINK", "OUTPUT")       :   "/OUT:",
    ("INTEL", "DLINK", "OUTPUT")       :   "/OUT:",
    ("INTEL", "ASMLINK", "OUTPUT")     :   "/OUT:",
    ("INTEL", "PCH", "OUTPUT")         :   "/Fp",
    ("INTEL", "ASM", "OUTPUT")         :   "/Fo",
    ("INTEL", "IPF", "ASM", "OUTPUT")  :   "-o ",

    ("GCC", "CC", "OUTPUT")        :   "-o ",
    ("GCC", "SLINK", "OUTPUT")     :   "-cr ",
    ("GCC", "DLINK", "OUTPUT")     :   "-o ",
    ("GCC", "ASMLINK", "OUTPUT")   :   "-o ",
    ("GCC", "PCH", "OUTPUT")       :   "-o ",
    ("GCC", "ASM", "OUTPUT")       :   "-o ",

    ("OUTPUT")                     : "-o "
}

IncludeFlag = {"MSFT" : "/I", "GCC" : "-I"}

class MakefileMacro(SequentialDict):
    def __init__(self, _template_=None):
        SequentialDict.__init__(self)
        if _template_ != None:
            # print "###",_template_
            for item in _template_:
                self[item[0]] = item[1]

    def __str__(self):
        s = ""
        for name,value in self.iteritems():
            if type(value) == type(""):
                s += "%s = %s\n" % (name, value)
            else:
                s += "%s = %s\n" % (name, " ".join(value))
        return s


# all targets
##ALL       Build everything for either the platform or module, based on tools_def.txt and possible restricted by target.txt
##GenC      Auto-generate all C files for either the platform or module (see below).
##GenMake   Generate the Makefiles ? if auto-generated files are missing, then auto-generate all C files first for either the platform or module (see below).
##BOM       Calls the MkBOM program for the platform
##PCH       Generate Pre-compiled Headers
##VFR       Generate IFR C files from VFR file
##Code      Nmake call on appropriate Makefile for either the platform or module (see below). (???)
##Fds       Create the FD Image files
##Libs      Build all EDK Libraries and EDK II Library Instances
##Modules   Build all EDK components and EDK II modules
##ROM       Build an OptionROM, not a bootable image
##App       Build an UEFI application, not a bootable image (?????)
##Clean     Remove intermediate files generated by the NMAKE command (leaving the auto-generated C format, FD image files, PE32 output files, PCH files and LIB files)
##CleanAll  Remove all intermmediate, auto-generated, FV and FD image files ? state of the tree should be exactly as if a fresh checkout or install has occurred
##CleanPch  Remove intermediate files generated by the NMAKE command AND PCH files (leaving the auto-generated, FV and FD image files, PE32 output files and LIB files)
##CleanLib  Remove intermediate files generated by the NMAKE command AND LIB files (leaving the auto-generated, FV and FD image files, PE32 output files and PCH files)
##CleanMod  Remove intermediate files generated by the NMAKE command and PE32 output files (leaving the auto-generated, FV and FD image files, PCH files and LIB files)
##CleanFd   Remove all FD image files

class MakefileTarget(object):
##    _Setter = {
##        "NAME"  :   MakefileTarget.SetTargetName,
##        "DEPS"  :   MakefileTarget.AddPrerequisite,
##        "CMDS"  :   MakefileTarget.AddCommand
##    }
##
##    _Getter = {
##        "NAME"  :   MakefileTarget.GetTarget,
##        "DEPS"  :   MakefileTarget.GetPrerequisite,
##        "CMDS"  :   MakefileTarget.GetCommand
##    }

    def __init__(self, _template=None, target=None, prerequisite=None, command=None):
        self.target = ""
        self.prerequisite = []
        self.command = []
        
        self._Setter = {
            "NAME"  :   MakefileTarget.SetTargetName,
            "DEPS"  :   MakefileTarget.AddPrerequisite,
            "CMDS"  :   MakefileTarget.AddCommand
        }

        self._Getter = {
            "NAME"  :   MakefileTarget.GetTarget,
            "DEPS"  :   MakefileTarget.GetPrerequisite,
            "CMDS"  :   MakefileTarget.GetCommand
        }

        if _template != None:
            for k in _template.keys():
                self._Setter[k](self, _template[k])
        else:
            if target != None: self.target = target
            if prerequisite != None: self.prerequisite = prerequisite
            if command != None: self.command = command
            
    def __str__(self):
        if self.target == None or self.target == "": return ""
        return "%s: %s\n\t%s\n" % (self.target, " ".join(self.prerequisite), "\n\t".join(self.command))

    def SetTargetName(self, name):
        self.target = name

    def AddPrerequisite(self, dep):
        if type(dep) == type(""):
            self.prerequisite.append(dep)
        else:
            self.prerequisite.extend(dep)

    def AddCommand(self, cmd):
        if type(cmd) == type(""):
            self.command.append(cmd)
        else:
            self.command.extend(cmd)

    def GetPrerequisite(self):
        return self.prerequisite

    def GetCommand(self):
        return self.command

    def GetTarget(self):
        return self.target


class MakefileContent(object):
    CONTENT_TYPE       = 0
    CONTENT_COMMENT    = 1
    CONTENT_TEMPLATE   = 2
    CONTENT_GENERATOR  = 3
    def __init__(self, templateList):
        if len(templateList) != 4:
            raise Except("Incorrect makefile template")
        self.Type = templateList[self.CONTENT_TYPE]
        self.Comment = templateList[self.CONTENT_COMMENT]
        self.Template = templateList[self.CONTENT_TEMPLATE]
        self.Generator = templateList[self.CONTENT_GENERATOR]

    def DefaultGenerator(self, template):
        return [self.Type(template)]

    def GenMakefileMacro(self, template):
        macro = MakefileMacro()
        for item in template:
            macro[item[0]] = item[1]
        return [macro]

    def GenMakefileTarget(self, template):
        target = MakefileTarget()
        for key in template:
            target[key] = template[key]
        return [target]
    
    def Generate(self):
        #print self.Template
        clist = []
        if self.Comment != None and self.Comment != "":
            clist.append(self.GenComment(self.Comment))
            
        if self.Generator == None or self.Generator == "":
            clist.extend(self.DefaultGenerator(self.Template))
        else:
            clist.extend(self.Generator(self.Template))
            
        return clist

    def GenComment(self, s):
        return "#\n# %s\n#\n" % s

class Makefile(object):
    def __init__(self, module, package, platform, workspace, tag, bt, arch, opt, mtype=MakeType):
        self.ContentList = []

        self.Workspace = workspace
        self.BuildModule = module
        self.Package = package
        self.Platform = platform
        
        self.ToolchainTag = tag
        self.BuildTarget = bt
        self.Arch = arch

        self.ToolDef = self.Workspace.ToolDef.ToolsDefTxtDictionary
        self.ToolType = self.Workspace.ToolDef.ToolsDefTxtDatabase["COMMAND_TYPE"]
        #self.ToolchainFamily = self.ToolDef.ToolsDefTxtDatabase["TOOLCHAIN_FAMILY"]

        self.WorkspaceDir = self.Workspace.Workspace.WorkspaceDir
        self.PackageDir = path.join(self.WorkspaceDir, path.dirname(self.Package.DescFilePath))

        self.PlatformDir = path.join(self.WorkspaceDir, path.dirname(self.Platform.DescFilePath))
        self.PlatformBuildDir = self.Platform.OutputDirectory
        if not path.isabs(self.PlatformBuildDir):
            self.PlatformBuildDir = path.join(self.WorkspaceDir, self.PlatformBuildDir)

        moduleRelativeDir = path.dirname(self.BuildModule.DescFilePath)
        self.ModuleDir = path.join(self.WorkspaceDir, moduleRelativeDir)
        self.ModuleFileBase, ext = path.splitext(path.basename(self.BuildModule.DescFilePath))
        self.ModuleBuildDir = path.join(self.PlatformBuildDir, "%s_%s" % (self.BuildTarget, self.ToolchainTag),
                                        self.Arch, moduleRelativeDir, self.ModuleFileBase)

        self.BuildType = "mbuild"
        if self.BuildModule.LibraryClass != None and self.BuildModule.LibraryClass != "":
            self.BuildType = "lbuild"
            
        self.ProcessSourceFileList()
        self.IncludePathList = self.GetIncludePathList()

        self.Opt = opt
        self.BuildWithPch = opt["ENABLE_PCH"]
        self.BuildWithLocalLib = opt["ENABLE_LOCAL_LIB"]

        self.MakefileTemplate = (
            (
                MakefileMacro, # type
                "Workspace related macro definition", # comment
                (# content
                    ("WORKSPACE_DIR"        , "$(WORKSPACE)"),
                    ("EDK_SOURCE"           , "$(WORKSPACE)")
                ),
                # generator
                None
            ),
            (
                MakefileMacro,    # type
                "PlatformMacro",
                (
                    ("PLATFORM_NAME"        ,   self.Platform.PlatformName),
                    ("PLATFORM_GUID"        ,   self.Platform.Guid),
                    ("PLATFORM_VERSION"     ,   self.Platform.Version),
                    ("PLATFORM_DIR"         ,   self.PlatformDir),
                    ("PLATFORM_OUTPUT_DIR"  ,   self.Platform.OutputDirectory),
                ),
                None
            ),
            (
                MakefileMacro,    # type
                "PackageMacro",
                (
                    ("PACKAGE_NAME"          ,   self.Package.PackageName),
                    ("PACKAGE_GUID"          ,   self.Package.Guid),
                    ("PACKAGE_VERSION"       ,   self.Package.Version),
                    ("PACKAGE_DIR"           ,   self.PackageDir),
                ),
                None
            ),
            (
                MakefileMacro,    # type
                "ModuleMacro",
                (
                    ("MODULE_NAME"          ,   self.BuildModule.BaseName),
                    ("MODULE_GUID"          ,   self.BuildModule.Guid),
                    ("MODULE_VERSION"       ,   self.BuildModule.Version),
                    ("MODULE_DIR"           ,   self.ModuleDir),
                    ("MODULE_TYPE"          ,   self.BuildModule.ModuleType),
                    ("MODULE_FILE_BASE_NAME",   self.ModuleFileBase),
                    ("BASE_NAME"            ,   "$(MODULE_NAME)"),
                ),
                None
            ),
            (
                MakefileMacro,    # type
                "BuildConfigMacro",
                (
                    ("ARCH"                 ,   "IA32"),
                    ("TOOLCHAIN_TAG"        ,   "MYTOOLS"),
                    ("TARGET"               ,   "DEBUG"),
                ),
                None
            ),
            (
                MakefileMacro,    # type
                "BuildDirMacro",
                (
                    ("PLATFORM_BUILD_DIR"   ,   self.PlatformBuildDir),
                    ("BUILD_DIR"            ,   "$(PLATFORM_BUILD_DIR)"),
                    ("BIN_DIR"              ,   path.join("$(BUILD_DIR)", "$(TARGET)_$(TOOLCHAIN_TAG)", "$(ARCH)")),
                    ("LIB_DIR"              ,   "$(BIN_DIR)"),
                    ("MODULE_BUILD_DIR"     ,   self.ModuleBuildDir),
                    ("OUTPUT_DIR"           ,   path.join("$(MODULE_BUILD_DIR)", "OUTPUT")),
                    ("DEBUG_DIR"            ,   path.join("$(MODULE_BUILD_DIR)", "DEBUG")),
                    ("DEST_DIR_OUTPUT"      ,   "$(OUTPUT_DIR)"),
                    ("DEST_DIR_DEBUG"       ,   "$(DEBUG_DIR)")
                ),
                None
            ),

            (
                MakefileMacro,    # type
                "DefaultToolsFlagMacro",
                (
                    self.GetDefaultToolFlagList()
                ),
                None
            ),
##            (
##                MakefileMacro,    # type
##                "PlatformToolsFlagMacro",
##                (
##                    self.GetPlatformToolFlagList()
##                ),
##                None
##            ),
            (
                MakefileMacro,    # type
                "ModuleToolsFlagMacro",
                (
                    self.GetModuleToolFlagList()
                ),
                None
            ),
            (
                MakefileMacro,    # type
                "ToolsFlagMacro",
                (
                    self.GetToolFlagList()
                ),
                None
            ),
            (
                MakefileMacro,    # type
                "ToolsPathMacro",
                (
                    self.GetToolPathList()
                ),
                None
            ),

            (
                MakefileMacro,    # type
                "BuildMacro",
                (
                    ("SOURCE_FILES", self.SourceFilePathList),
                    ("INC", self.IncludePathList),
                    ("OBJECTS", self.GetObjectFileList()),
                    ("LIBS", self.GetLibraryFileList()),
                    ("ENTRYPOINT", "_ModuleEntryPoint")
                ),
                None
            ),
            (
                MakefileMacro,    # type
                "BuildFileMacro",
                (
                    ("PCH_FILE", "$(OUTPUT_DIR)\\$(MODULE_NAME).pch"),
                    ("LIB_FILE", "$(LIB_DIR)\$(MODULE_NAME).lib"),
                    ("LLIB_FILE", "$(OUTPUT_DIR)\$(MODULE_NAME)Local.lib"),
                    ("DLL_FILE", path.join("$(DEBUG_DIR)", "$(MODULE_NAME).dll")),
                    ("EFI_FILE", path.join("$(OUTPUT_DIR)", "$(MODULE_NAME).efi"))
                ),
                None
            ),

            (
                MakefileMacro,    # type
                "BuildTargetMacro",
                (
                    ("INIT_TARGET", "init"),
                    ("PCH_TARGET", self.GetPchTarget()),
                    ("LLIB_TARGET", self.GetLocalLibTarget()),
                ),
                None
            ),

            (
                MakefileTarget,   # type
                "Default target, which will build dependent libraries in addition to source files",
                {
                    "NAME" : "all",
                    "DEPS" : [self.BuildType],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "Target used when called from platform makefile, which will bypass the build of dependent libraries",
                {
                    "NAME" : "pbuild",
                    "DEPS" : ["$(INIT_TARGET)", "$(PCH_TARGET)", "gen_obj", "$(LLIB_TARGET)", "$(DLL_FILE)", "$(EFI_FILE)"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "Target used for library build, which will bypass the build of dependent libraries",
                {
                    "NAME" : "lbuild",
                    "DEPS" : ["$(INIT_TARGET)", "$(PCH_TARGET)", "gen_obj", "$(LIB_FILE)"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "ModuleTarget",
                {
                    "NAME" : "mbuild",
                    "DEPS" : ["$(INIT_TARGET)", "gen_libs", "$(PCH_TARGET)", "gen_obj", "$(LLIB_TARGET)", "$(DLL_FILE)", "$(EFI_FILE)"],
                    "CMDS" : []
                },
                None
            ),

            (
                MakefileTarget,   # type
                "BuildInfoTarget",
                {
                    "NAME" : "init",
                    "DEPS" : [],
                    "CMDS" : ["@echo $(MODULE_NAME)-$(MODULE_VERSION) [$(ARCH)] from package $(PACKAGE)-$(PACKAGE_VERSION) $(MODULE_DIR)"]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "PchTarget",
                {
                    "NAME" : "pch",
                    "DEPS" : ["$(PCH_FILE)"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "LibsTarget",
                {
                    "NAME" : "libs",
                    "DEPS" : ["gen_libs"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "VfrTarget",
                {
                    "NAME" : "vfr",
                    "DEPS" : ["gen_vfr"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "ObjTarget",
                {
                    "NAME" : "obj",
                    "DEPS" : ["$(PCH_TARGET)", "gen_obj"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "LocalLibTarget",
                {
                    "NAME" : "locallib",
                    "DEPS" : ["$(PCH_TARGET)", "gen_obj", "$(LIB_FILE)"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "DllTarget",
                {
                    "NAME" : "dll",
                    "DEPS" : ["gen_libs", "$(PCH_TARGET)", "gen_obj", "$(LLIB_TARGET)", "$(DLL_FILE)"],
                    "CMDS" : []
                },
                None
            ),
            (
                MakefileTarget,   # type
                "EfiTarget",
                {
                    "NAME" : "efi",
                    "DEPS" : ["gen_libs", "$(PCH_TARGET)", "gen_obj", "$(LLIB_TARGET)", "$(DLL_FILE)", "$(EFI_FILE)"],
                    "CMDS" : []
                },
                None
            ),

            (
                MakefileTarget,   # type
                "GenLibsTarget",
                {
                    "NAME" : "gen_libs",
                    "DEPS" : [],
                    "CMDS" : self.GetLibraryBuildCmdList() # ["$(MAKE) $(MAKE_FLAGS) -f %(LIB_MAKEFILE)s"]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "GenVfrTarget",
                {
                    "NAME" : "gen_vfr",
                    "DEPS" : [],
                    "CMDS" : ["@echo placeholder: processing vfr files"]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "Phony targets for objects",
                {
                    "NAME" : "gen_obj",
                    "DEPS" : ["$(PCH_TARGET)", "$(OBJECTS)"],
                    "CMDS" : [""]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "PCH file build target",
                {
                    "NAME" : "$(PCH_FILE)",
                    "DEPS" : ["$(DEP_FILES)"],
                    "CMDS" : ["$(PCH) $(CC_FLAGS) $(PCH_FLAGS) $(DEP_FILES)"]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "Local Lib file build target",
                {
                    "NAME" : "$(LLIB_FILE)",
                    "DEPS" : ["$(OBJECTS)"],
                    "CMDS" : ["\"$(SLINK)\" %(OUTPUT_FLAG)s$(LIB_FILE) $(SLINK_FLAGS) $(OBJECTS)" % {"OUTPUT_FLAG":OutputFlag["MSFT", "SLINK", "OUTPUT"]}]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "Library file build target",
                {
                    "NAME" : "$(LIB_FILE)",
                    "DEPS" : ["$(OBJECTS)"],
                    "CMDS" : ["\"$(SLINK)\" %(OUTPUT_FLAG)s$(LIB_FILE) $(SLINK_FLAGS) $(OBJECTS)" % {"OUTPUT_FLAG":OutputFlag["MSFT", "SLINK", "OUTPUT"]}]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "DLL file build target",
                {
                    "NAME" : "$(DLL_FILE)",
                    "DEPS" : ["$(LIBS)", "$(LIB_FILE)"],
                    "CMDS" : ["\"$(DLINK)\" %(OUTPUT_FLAG)s$(DLL_FILE) $(DLINK_FLAGS) $(LIBS) $(LIB_FILE)" % {"OUTPUT_FLAG":OutputFlag["MSFT", "DLINK", "OUTPUT"]}]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "EFI file build target",
                {
                    "NAME" : "$(EFI_FILE)",
                    "DEPS" : ["$(DLL_FILE)"],
                    "CMDS" : ["echo $(GENFW) $(GENFW_FLAGS) -o $(EFI_FILE) $(DLL_FILE)"]
                },
                None
            ),
            (
##                type(MakefileMacro),            # type
##                "dependent files macro for the target",
##                (
##                    self.GetObjectDeps()
##                ),
##                None,
##\tcd $(@D)
##\t$(APP) $(APP_FLAGS) $(INC) $<
##\tTrim -CONVERT $(@D).i
##\t$(ASM) $(ASM_FLAGS) $(INC) /Fo$@ $(@D).iii

                MakefileTarget,   # type
                "Individual Object Build Targets",
                {
                    ".C" : "\"$(CC)\" %(OUTPUT_FLAG)s%(OUTPUT_FILE)s $(CC_FLAGS) $(INC) %(INPUT_FLAG)s%(INPUT_FILE)s",
                    ".ASM" : "cd $(@D)\n\t\"$(PP)\" $(PP_FLAGS) $(INC) $? > $@.i\n\tTrim -CONVERT $@.i\n\t\"$(ASM)\" $(ASM_FLAGS) %(OUTPUT_FLAG)s%(OUTPUT_FILE)s $@.iii",
                    #".S" : "$(ASM) $(ASM_FLAGS) %(OUTPUT_FLAG)s%(OUTPUT_FILE)s %(INPUT_FLAG)s%(INPUT_FILE)s"
                },
##                {
##                    "NAME" : "%(OBJECT)s",
##                    "DEPS" : ["$(DEP_FILES)"],
##                    "CMDS" : ["$(CC) %(OUTPUT_FLAG)s%(OBJECT)s $(CC_FLAGS) $(INC) %(SOURCE_FILE)s"]
##                },
                self.GetObjectTargetList
            ),
            (
                MakefileTarget,   # type
                "clean all intermediate files",
                {
                    "NAME" : "clean",
                    "DEPS" : [],
                    "CMDS" : ["@echo clean all intermediate files"]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "clean all generated files",
                {
                    "NAME" : "cleanall",
                    "DEPS" : [],
                    "CMDS" : ["@echo clean all generated files"]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "clean pre-compiled header files",
                {
                    "NAME" : "cleanpch",
                    "DEPS" : [],
                    "CMDS" : ["@echo clean pre-compiled header files"]
                },
                None
            ),
            (
                MakefileTarget,   # type
                "clean all dependent libraries built",
                {
                    "NAME" : "cleanlib",
                    "DEPS" : [],
                    "CMDS" : ["@echo clean all dependent libraries built"]
                },
                None
            ),
        )

    def PrepareDirectory(self):
        CreateDirectory(self.PlatformBuildDir)
        CreateDirectory(self.ModuleBuildDir)
        CreateDirectory(path.join(self.ModuleBuildDir, "OUTPUT"))
        CreateDirectory(path.join(self.ModuleBuildDir, "DEBUG"))

    def Generate(self, file=None):
        self.PrepareDirectory()
        filePath = ""
        if file == None:
            filePath = path.join(self.ModuleBuildDir, "makefile")
        else:
            filePath = file
            
        try:
            f = open(filePath, "w")
        except:
            return ""
        
        self.Instantiate()
        for c in self.ContentList:
            f.write("%s\n" % c)
        f.close()
        return filePath
            
    def Instantiate(self):
        for item in self.MakefileTemplate:
            self.ContentList.extend(MakefileContent(item).Generate())


    def GetDefaultToolFlagList(self):
        toolFlag = []
        arch = self.Arch.upper()
        for tool in self.ToolType:
            defkey = "%s_%s_%s_%s_FLAGS" % (self.BuildTarget, self.ToolchainTag,
                                            arch, tool)
            if defkey in self.ToolDef:
                defValue = self.ToolDef[defkey]
            else:
                defValue = ""
            toolFlag.append(("DEFAULT_%s_FLAGS" % tool, defValue))
        return toolFlag

    def GetPlatformToolFlagList(self):
        buildopt = self.Platform.BuildOptionDatabase
        toolFlag = []
        for key in buildopt:
            target, tag, arch, tool, flags = key.split("_")
            if arch != self.Arch or target != self.BuildTarget or tag != self.ToolchainTag:
                continue
            toolFlag.append(("PLATFORM_%s_FLAGS" % tool, buildopt[key]))

        

    def GetModuleToolFlagList(self):
        buildopt = self.BuildModule.BuildOptions
        toolFlag = []
        for key in buildopt:
            target, tag, arch, tool, flags = key.split("_")
            if arch != self.Arch.upper() or target != self.BuildTarget or tag != self.ToolchainTag:
                flag = ""
            else:
                flag = buildopt[key]
            toolFlag.append(("MODULE_%s_FLAGS" % tool, flag))

    def GetToolFlagList(self):
        toolFlag = []
        for tool in self.ToolType:
            toolFlag.append(("%s_FLAGS" % tool,
                            "$(DEFAULT_%s_FLAGS) $(MODULE_%s_FLAGS)" % (tool, tool)))
        return toolFlag

    def GetSysLibList(self):
        libPath = []
        for tool in self.ToolType:
            pathkey = "%s_%s_%s_%s_SPATH" % (self.BuildTarget, self.ToolchainTag,
                                             self.Arch, tool)

            spath = ""
            if pathkey in td:
                spath = self.ToolDef[pathkey]

            libPath.append(("%s_SPATH" % tool, spath))

        return libPath

    def GetToolPathList(self):
        toolPathList = []
        arch = self.Arch.upper()
        for tool in self.ToolType:
            pathkey = "%s_%s_%s_%s_PATH" % (self.BuildTarget, self.ToolchainTag,
                                            arch, tool)
            toolkey = "%s_%s_%s_%s_NAME" % (self.BuildTarget, self.ToolchainTag,
                                            arch, tool)

            #print pathkey
            #print toolkey
            toolpath = ""
            if pathkey in self.ToolDef:
                toolpath = self.ToolDef[pathkey]
                
            if toolkey not in self.ToolDef:
                continue
            toolName = self.ToolDef[toolkey]
            if toolName == None or toolName == "":
                continue
        
            toolPathList.append((tool, path.join(toolpath, toolName)))

        return toolPathList

    def ProcessSourceFileList(self):
        self.SourceFilePathList = []
        self.ObjectFilePathList = []
        self.ObjectTargetList = []
        if self.BuildModule.LibraryClass == None or self.BuildModule.LibraryClass == "":
            self.SourceFilePathList.append("$(DEBUG_DIR)\\.\\AutoGen.c")
            self.ObjectFilePathList.append("$(OUTPUT_DIR)\\.\\AutoGen.obj")
            ftype = "AutoGen-Code"
            self.ObjectTargetList.append(Rule.Makefile[MakeType][ftype] % {
                                         "fdir":".", "fbase":"AutoGen", "fext":".c", "fname":"AutoGen.c"
                                         })
        fileList = self.BuildModule.Sources
        for f in fileList:
            if f.TagName != "" and f.TagName != self.ToolchainTag: continue
            if f.ToolCode != "" and f.ToolCode not in self.ToolType: continue
            if f.ToolChainFamily != "" and f.ToolChainFamily not in self.ToolChainFamily:
                continue
            f = path.normpath(f.SourceFile)
            name = path.basename(f)
            base, ext = path.splitext(name)
            basedir = path.dirname(f)
            if basedir == "":
                basedir = "."
            if base.endswith("Gcc"):
                continue
            if ext not in Rule.FileTypeMapping:
                continue
            ftype = Rule.FileTypeMapping[ext]
            if ftype not in Rule.Makefile[MakeType]:
                continue

            src = path.join("$(MODULE_DIR)", f)
            self.SourceFilePathList.append(src)
            objPath = path.join("$(OUTPUT_DIR)", basedir)
            CreateDirectory(path.join(self.ModuleBuildDir, "OUTPUT", basedir))
            obj = path.join("$(OUTPUT_DIR)", basedir, base + ".obj")
            self.ObjectFilePathList.append(obj)
            self.ObjectTargetList.append(Rule.Makefile[MakeType][ftype] % {
                                         "fdir":basedir, "fbase":base, "fext":ext, "fname":name
                                         })

    def GetSourceFileList(self):
        return self.SourceFilePathList
    
    def GetIncludePathList(self):
        includePathList = ["-I$(MODULE_DIR)", "-I$(WORKSPACE_DIR)"]
        for inc in self.BuildModule.Includes:
            #print "$$$",inc
            includePathList.append("-I" + path.normpath(path.join("$(WORKSPACE_DIR)", inc)))
        for inc in self.Package.Includes:
            #print "###",inc
            includePathList.append("-I" + path.normpath(path.join("$(PACKAGE_DIR)", inc)))
        for pkgfile in self.BuildModule.Packages:
            pkg = self.Workspace.Build[self.Arch].PackageDatabase[pkgfile]
            pkgdir = path.dirname(pkg.DescFilePath)
            includePathList.append("-I" + path.join("$(WORKSPACE_DIR)", pkgdir, "Include"))
            includePathList.append("-I" + path.join("$(WORKSPACE_DIR)", pkgdir, "Include", self.Arch))
        return includePathList

    def GetObjectFileList(self):
        return self.ObjectFilePathList

    def GetLibraryFileList(self):
        libFileList = []
        libModuleList = [self.BuildModule]
        moduleType = self.BuildModule.ModuleType
        while len(libModuleList) > 0:
            module = libModuleList.pop()
            for libc, libf in module.LibraryClasses.iteritems():
                #print libc
                if libf == None or libf == "" or moduleType not in libc:
                    #print "No instance for", libc
                    continue
                
                libm = self.Workspace.Build[self.Arch].ModuleDatabase[libf]
                libFilePath = path.join("$(LIB_DIR)", libm.BaseName + ".lib")
                if libFilePath in libFileList:
                    continue
                
                libFileList.append(libFilePath)
                libModuleList.append(libm)
            
        return libFileList

    def GetDependentLibraryList(self, module):
        pass
    
    def GetPchTarget(self):
        if not self.BuildWithPch: return ""
        return "$(PCH_FILE)"

    def GetLocalLibTarget(self):
        if self.BuildWithLocalLib: 
            return "$(LLIB_FILE)"
        return ""

    def GetLibraryBuildCmdList(self):
        libMakefileList = []
        libModuleList = [self.BuildModule]
        moduleType = self.BuildModule.ModuleType
        #print "###",
        while len(libModuleList) > 0:
            module = libModuleList.pop()
            #print " Module", module.BaseName,"type", module.ModuleType
            for libc, libf in module.LibraryClasses.iteritems():
                #print "   ",libc
                if libf == None or libf == "" or moduleType not in libc:
                    #print "    $$$",libc[0],"doesn't support",moduleType
                    continue
                libm = self.Workspace.Build[self.Arch].ModuleDatabase[libf]
                #print "        ",libm.BaseName
                libp = path.dirname(libf)
                base = path.basename(libf).split(".")[0]
                makefilePath = path.join("$(BIN_DIR)", libp, base, "Makefile")
                #makefilePath = path.normpath(makefilePath)
                makeCmd = "$(MAKE) $(MAKE_FLAGS) -f %s" % makefilePath
                if makeCmd in libMakefileList:
                    continue
                libMakefileList.append(makeCmd)
                libModuleList.append(libm)

        return libMakefileList

    def GetObjectDepList(self):
        pass

    def GetObjectTargetList(self, template):
##        for i in range(0, len(self.SourceFilePathList)):
##            src = self.SourceFilePathList[i]
##            obj = self.ObjectFilePathList[i]
##            base, ext = path.splitext(src)
##            ext = ext.upper()
##            if ext not in template: continue
##            cmd = template[ext] % {"OUTPUT_FLAG":"/Fo", "OUTPUT_FILE":obj,
##                                   "INPUT_FLAG":"", "INPUT_FILE":src}
##            self.ObjectTargetList.append(MakefileTarget(target=obj, prerequisite=[src], command=[cmd]))
        return self.ObjectTargetList

def FindModuleOwner(module, pkgdb):
    for pkg in pkgdb:
        pkgDir = path.dirname(pkg)
        if module.find(pkgDir) == 0:
            return pkgdb[pkg]
    return None


def LoadBuildRule(RuleFile):
    '''load build rule from specified file which is written in Python code format'''
    global Rule
    Rule = imp.load_source("BuildRule", RuleFile)
    
# This acts like the main() function for the script, unless it is 'import'ed into another
# script.
if __name__ == '__main__':
    print "Running Operating System =", sys.platform
    ewb = WorkspaceBuild()
    #print ewb.Build.keys()
    
    myArch = ewb.Build["IA32"].Arch
    #print myArch

    myBuild = ewb.Build["IA32"]
    
    myWorkspace = ewb
    apf = ewb.TargetTxt.TargetTxtDictionary["ACTIVE_PLATFORM"][0]
    myPlatform = myBuild.PlatformDatabase[os.path.normpath(apf)]

    LoadBuildRule(myWorkspace.Workspace.WorkspaceFile('Tools/Conf/build.rule'))
    #mf = "EdkModulePkg/Application/HelloWorld/HelloWorld.inf"
    for mf in myBuild.ModuleDatabase:
        #mf = "MdePkg\\Library\\BaseLib\\BaseLib.inf"
        #if mf in myPlatform.Modules and mf in myBuild.ModuleDatabase:
        #print mf

        myModule = myBuild.ModuleDatabase[mf]

        myPackage = FindModuleOwner(myModule.DescFilePath, myBuild.PackageDatabase)

        myToolchain = ewb.TargetTxt.TargetTxtDictionary["TOOL_CHAIN_TAG"][0]
        #print myToolchain

        myBuildTarget = ewb.TargetTxt.TargetTxtDictionary["TARGET"][0]
        #print myBuildTarget

        myBuildOption = {
            "ENABLE_PCH"        :   False,
            "ENABLE_LOCAL_LIB"  :   True,
        }

        myMakefile = Makefile(myModule, myPackage, myPlatform, myWorkspace, myToolchain, myBuildTarget,
                              myArch, myBuildOption, "nmake")

        myMakefile.Generate()
