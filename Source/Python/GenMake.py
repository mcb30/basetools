#!/usr/bin/env python

"""Create GNU Makefiles for the Libraries of the MdePkg."""

import os, sys, string, re
import os.path as path

from SequentialDict import *
from EdkIIWorkspaceBuild import *
from EdkIIWorkspace import *
from BuildInfo import *

gDependencyDatabase = {}    # file path : [dependent files list]
gIncludePattern = re.compile("^[ \t#]*include[ \t]+[\"<]*([^\"<>]+)[>\" \t\n\r]*", re.MULTILINE | re.UNICODE)

class AutoGenString(object):
    def __init__(self):
        self.String = ''

    def __str__(self):
        return self.String

    def Append(self, AppendString, Dictionary=None):
        if Dictionary == None:
            self.String += AppendString
        else:
            while AppendString.find('${BEGIN}') >= 0:
                Start = AppendString.find('${BEGIN}')
                End   = AppendString.find('${END}')
                SubString = AppendString[AppendString.find('${BEGIN}'):AppendString.find('${END}')+6]
                
                RepeatTime = -1
                NewDict = {"BEGIN":"", "END":""}
                for Key in Dictionary:
                    if SubString.find('$' + Key) >= 0 or SubString.find('${' + Key + '}') >= 0:
                        Value = Dictionary[Key]
                        if type(Value) != type([]):
                            NewDict[Key] = Value
                            continue
                        if RepeatTime < 0:
                            RepeatTime = len(Value)
                        elif RepeatTime != len(Value):
                            raise Exception(Key + " has different repeat time from others!")
                        NewDict[Key] = ""

                NewString = ''
                for Index in range(0, RepeatTime):
                    for Key in NewDict:
                        if Key == "BEGIN" or Key == "END" or type(Dictionary[Key]) != type([]):
                            continue
                        #print "###",Key
                        NewDict[Key] = Dictionary[Key][Index]
                    NewString += string.Template(SubString).safe_substitute(NewDict)
                AppendString = AppendString[0:Start] + NewString + AppendString[End + 6:]

            NewDict = {}
            for Key in Dictionary:
                if type(Dictionary[Key]) == type([]):
                    continue
                NewDict[Key] = Dictionary[Key]
            self.String += string.Template(AppendString).safe_substitute(NewDict)


MakefileHeader = '''#
# DO NOT EDIT
# This file is auto-generated by build utility
#
# Module Name:
#
#   %(MAKEFILE_NAME)s
#
# Abstract:
#
#   Auto-generated makefile for building module and libraries
#
'''

LibraryMakeCommand = '''cd %(makedir)s
\t$(MAKE) $(MAKE_FLAGS) -f %(makefile)s %(target)s
\tcd $(MODULE_BUILD_DIR)'''

gMakeType = ""
if sys.platform == "win32":
    gMakeType = "nmake"
else:
    gMakeType = "gmake"

gMakefileName = {"nmake" : "makefile", "gmake" : "GNUmakefile"}

gDirectorySeparator = {"nmake" : "\\", "gmake" : "/"}

OutputFlag = {
    ("MSFT", "CC", "OUTPUT")      :   "/Fo",
    ("MSFT", "SLINK", "OUTPUT")   :   "/OUT:",
    ("MSFT", "DLINK", "OUTPUT")   :   "/OUT:",
    ("MSFT", "ASMLINK", "OUTPUT") :   "/OUT:",
    ("MSFT", "PCH", "OUTPUT")     :   "/Fp",
    ("MSFT", "ASM", "OUTPUT")     :   "/Fo",
    
    ("INTEL", "CC", "OUTPUT")          :   "/Fo",
    ("INTEL", "SLINK", "OUTPUT")       :   "/OUT:",
    ("INTEL", "DLINK", "OUTPUT")       :   "/OUT:",
    ("INTEL", "ASMLINK", "OUTPUT")     :   "/OUT:",
    ("INTEL", "PCH", "OUTPUT")         :   "/Fp",
    ("INTEL", "ASM", "OUTPUT")         :   "/Fo",
    ("INTEL", "IPF", "ASM", "OUTPUT")  :   "-o ",

    ("GCC", "CC", "OUTPUT")        :   "-o ",
    ("GCC", "SLINK", "OUTPUT")     :   "-cr ",
    ("GCC", "DLINK", "OUTPUT")     :   "-o ",
    ("GCC", "ASMLINK", "OUTPUT")   :   "-o ",
    ("GCC", "PCH", "OUTPUT")       :   "-o ",
    ("GCC", "ASM", "OUTPUT")       :   "-o ",

    ("OUTPUT")                     : "-o "
}

IncludeFlag = {"MSFT" : "/I", "GCC" : "-I"}

gModuleMakefileTemplate = '''
#
# Workspace related macro definition
#
WORKSPACE_DIR = $(WORKSPACE)
EDK_SOURCE = $(WORKSPACE)

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}
PLATFORM_RELATIVE_DIR = ${platform_relative_directory}
PLATFORM_DIR = $(WORKSPACE_DIR)${separator}$(PLATFORM_RELATIVE_DIR)
PLATFORM_OUTPUT_DIR = ${platform_output_directory}

#
# Package Macro Definition
#
PACKAGE_NAME = ${package_name}
PACKAGE_GUID = ${package_guid}
PACKAGE_VERSION = ${package_version}
PACKAGE_RELATIVE_DIR = ${package_relative_directory}
PACKAGE_DIR = $(WORKSPACE)${separator}$(PACKAGE_RELATIVE_DIR)

#
# Module Macro Definition
#
MODULE_NAME = ${module_name}
MODULE_GUID = ${module_guid}
MODULE_VERSION = ${module_version}
MODULE_TYPE = ${module_type}
MODULE_FILE_BASE_NAME = ${module_file_base_name}
BASE_NAME = $(MODULE_NAME)
MODULE_RELATIVE_DIR = ${module_relative_directory}
MODULE_DIR = $(WORKSPACE_DIR)${separator}$(MODULE_RELATIVE_DIR)

#
# Build Configuration Macro Definition
#
ARCH = ${architecture}
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}

#
# Build Directory Macro Definition
#
PLATFORM_BUILD_DIR = ${platform_build_directory}
BUILD_DIR = $(PLATFORM_BUILD_DIR)${separator}$(TARGET)_$(TOOLCHAIN_TAG)${separator}$(ARCH)
BIN_DIR = $(BUILD_DIR)
LIB_DIR = $(BIN_DIR)
MODULE_BUILD_DIR = $(BUILD_DIR)${separator}$(MODULE_RELATIVE_DIR)${separator}$(MODULE_FILE_BASE_NAME)
OUTPUT_DIR = $(MODULE_BUILD_DIR)${separator}OUTPUT
DEBUG_DIR = $(MODULE_BUILD_DIR)${separator}DEBUG
DEST_DIR_OUTPUT = $(OUTPUT_DIR)
DEST_DIR_DEBUG = $(DEBUG_DIR)

#
# Default Tools Flags Macro Definition (from tools_def.txt by default)
#
${BEGIN}DEFAULT_${tool_code}_FLAGS = ${default_tool_flags}
${END}

#
# Platform Tools Flags Macro Definition (from platform description file)
#
${BEGIN}PLATFORM_${tool_code}_FLAGS = ${platform_tool_flags}
${END}

#
# Platform Tools Flags Macro Definition (from platform description file)
#
${BEGIN}MODULE_${tool_code}_FLAGS = ${module_tool_flags}
${END}

#
# ToolsFlagMacro
#
${BEGIN}${tool_code}_FLAGS = $(DEFAULT_${tool_code}_FLAGS) $(PLATFORM_${tool_code}_FLAGS) $(MODULE_${tool_code}_FLAGS)
${END}
MAKE_FLAGS = /nologo

#
# ToolsPathMacro
#
${BEGIN}${tool_code} = ${tool_path}
${END}

#
# BuildMacro
#
SOURCE_FILES = ${BEGIN}$(MODULE_DIR)${separator}${source_file} \\
               ${END}${BEGIN}$(DEBUG_DIR)${separator}${auto_generated_file}
               ${END}

INC = ${BEGIN}${include_path_prefix}$(WORKSPACE_DIR)${separator}${include_path} \\
      ${END}

OBJECTS = ${BEGIN}$(OUTPUT_DIR)${separator}${object_file} \\
          ${END}

LIBS = ${BEGIN}$(LIB_DIR)${separator}${library_file} \\
       ${END}

ENTRYPOINT = _ModuleEntryPoint

#
# Target File Macro Definitions
#
PCH_FILE = $(OUTPUT_DIR)\$(MODULE_NAME).pch
LIB_FILE = $(LIB_DIR)\$(MODULE_NAME).lib
LLIB_FILE = $(OUTPUT_DIR)\$(MODULE_NAME)Local.lib
DLL_FILE = $(DEBUG_DIR)\$(MODULE_NAME).dll
EFI_FILE = $(OUTPUT_DIR)\$(MODULE_NAME).efi

#
# Overridable Target Macro Definitions
#
INIT_TARGET = init
PCH_TARGET =
LLIB_TARGET = $(LLIB_FILE)

#
# Default target, which will build dependent libraries in addition to source files
#

all: ${build_type}


#
# Target used when called from platform makefile, which will bypass the build of dependent libraries
#

pbuild: $(INIT_TARGET) $(PCH_TARGET) gen_obj $(LLIB_TARGET) $(DLL_FILE) $(EFI_FILE)


#
# Target used for library build, which will bypass the build of dependent libraries
#

lbuild: $(INIT_TARGET) $(PCH_TARGET) gen_obj $(LIB_FILE)


#
# ModuleTarget
#

mbuild: $(INIT_TARGET) gen_libs $(PCH_TARGET) gen_obj $(LLIB_TARGET) $(DLL_FILE) $(EFI_FILE)


#
# Initialization target: print build information and create necessary directories
#
init:
	-@echo Building ... $(MODULE_NAME)-$(MODULE_VERSION) [$(ARCH)] in package $(PACKAGE_NAME)-$(PACKAGE_VERSION)
	${create_directory_command} $(DEBUG_DIR) > NUL 2>&1
	${create_directory_command} $(OUTPUT_DIR) > NUL 2>&1
	${BEGIN}${create_directory_command} $(OUTPUT_DIR)${separator}${directory_to_be_created} > NUL 2>&1
	${END}

#
# PCH Target
#
pch: $(PCH_FILE)


#
# Libs Target
#
libs: gen_libs


#
# Vfr Target
#
vfr: gen_vfr


#
# Obj Target
#
obj: $(PCH_TARGET) gen_obj


#
# LocalLib Target
#
locallib: $(PCH_TARGET) gen_obj $(LLIB_FILE)


#
# Dll Target
#
dll: gen_libs $(PCH_TARGET) gen_obj $(LLIB_TARGET) $(DLL_FILE)


#
# Efi Target
#
efi: gen_libs $(PCH_TARGET) gen_obj $(LLIB_TARGET) $(DLL_FILE) $(EFI_FILE)


#
# GenLibsTarget
#
gen_libs:
	${BEGIN}cd $(BUILD_DIR)${separator}${dependent_library_build_directory}
	$(MAKE) $(MAKE_FLAGS)
	${END}cd $(MODULE_BUILD_DIR)

#
# GenVfrTarget
#

gen_vfr:
	@echo placeholder: processing vfr files

#
# Phony targets for objects
#

gen_obj: $(PCH_TARGET) $(OBJECTS)


#
# PCH file build target
#

$(PCH_FILE): $(DEP_FILES)
	$(PCH) $(CC_FLAGS) $(PCH_FLAGS) $(DEP_FILES)

#
# Local Lib file build target
#

$(LLIB_FILE): $(OBJECTS)
	"$(SLINK)" /OUT:$(LLIB_FILE) $(SLINK_FLAGS) $(OBJECTS)

#
# Library file build target
#

$(LIB_FILE): $(OBJECTS)
	"$(SLINK)" /OUT:$(LIB_FILE) $(SLINK_FLAGS) $(OBJECTS)

#
# DLL file build target
#

$(DLL_FILE): $(LIBS) $(LLIB_FILE)
	"$(DLINK)" /OUT:$(DLL_FILE) $(DLINK_FLAGS) $(LIBS) $(LLIB_FILE)

#
# EFI file build target
#

$(EFI_FILE): $(DLL_FILE)
	echo $(GENFW) $(GENFW_FLAGS) -o $(EFI_FILE) $(DLL_FILE)

#
# Individual Object Build Targets
#
${BEGIN}${object_build_target}
${END}


#
# clean all intermediate files
#

clean:
	- @rmdir /s /q $(OUTPUT_DIR) > NUL 2>&1

#
# clean all generated files
#

cleanall:
	- @rmdir /s /q $(OUTPUT_DIR) $(DEBUG_DIR) > NUL 2>&1
	- @del /f /q *.pdb *.idb > NUL 2>&1

#
# clean pre-compiled header files
#

cleanpch:
	- @del /f /q $(OUTPUT_DIR)\*.pch > NUL 2>&1

#
# clean all dependent libraries built
#

cleanlib:
	@echo clean all dependent libraries built

'''

gPlatformMakefileTemplate = '''
'''

class Makefile(object):
    def __init__(self, info, opt):
        self.ModuleInfo = info
        self.PlatformInfo = info.PlatformInfo
        self.PackageInfo = info.PackageInfo

        self.BuildType = "mbuild"
        if self.ModuleInfo.IsLibrary:
            self.BuildType = "lbuild"
            
        self.Opt = opt
        self.BuildWithPch = opt["ENABLE_PCH"]
        self.BuildWithLocalLib = opt["ENABLE_LOCAL_LIB"]

        self.LibraryBuildCommandList = []
        self.LibraryFileList = []
        self.LibraryMakefileList = []
        self.LibraryBuildDirectoryList = []
        self.BuildFileList = []
        self.ObjectFileList = []
        self.ObjectBuildTargetList = []

        self.FileDependency = []
        self.IntermediateDirectoryList = []

    def PrepareDirectory(self):
        CreateDirectory(path.join(self.ModuleInfo.WorkspaceDir, self.PlatformInfo.BuildDir))
        CreateDirectory(path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.BuildDir))
        CreateDirectory(path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.DebugDir))

    def Generate(self, file=None, makeType=gMakeType):
        separator = gDirectorySeparator[makeType]
        
        if os.path.isabs(self.PlatformInfo.OutputDir):
            self.PlatformBuildDirectory = self.PlatformInfo.OutputDir
        else:
            self.PlatformBuildDirectory = "$(WORKSPACE_DIR)" + separator + self.PlatformInfo.OutputDir

        self.ProcessSourceFileList(makeType)
        self.ProcessDependentLibrary(makeType)
        
        makefileName = gMakefileName[makeType]
        makefileTemplateDict = {
            "platform_name"             : self.PlatformInfo.Name,
            "platform_guid"             : self.PlatformInfo.Guid,
            "platform_version"          : self.PlatformInfo.Version,
            "platform_relative_directory": self.PlatformInfo.SourceDir,
            "platform_output_directory" : self.PlatformInfo.OutputDir,

            "package_name"              : self.PackageInfo.Name,
            "package_guid"              : self.PackageInfo.Guid,
            "package_version"           : self.PackageInfo.Version,
            "package_relative_directory": self.PackageInfo.SourceDir,

            "module_name"               : self.ModuleInfo.Name,
            "module_guid"               : self.ModuleInfo.Guid,
            "module_version"            : self.ModuleInfo.Version,
            "module_type"               : self.ModuleInfo.ModuleType,
            "module_file_base_name"     : self.ModuleInfo.FileBase,
            "module_relative_directory" : self.ModuleInfo.SourceDir,

            "architecture"              : self.ModuleInfo.Arch,
            "toolchain_tag"             : self.ModuleInfo.ToolChain,
            "build_target"              : self.ModuleInfo.BuildTarget,

            "platform_build_directory"  : self.PlatformBuildDirectory,

            "separator"                 : separator,
            "default_tool_flags"        : self.PlatformInfo.DefaultToolOption.values(),
            "platform_tool_flags"       : self.PlatformInfo.BuildOption.values(),
            "module_tool_flags"         : self.ModuleInfo.BuildOption.values(),

            "tool_code"                 : self.PlatformInfo.ToolPath.keys(),
            "tool_path"                 : self.PlatformInfo.ToolPath.values(),

            "source_file"               : self.BuildFileList,
            "auto_generated_file"       : self.AutoGenBuildFileList,
            "include_path_prefix"       : "-I",
            "include_path"              : self.ModuleInfo.IncludePathList,
            "object_file"               : self.ObjectFileList,
            "library_file"              : self.LibraryFileList,
            "create_directory_command"  : "-@mkdir",
            "directory_to_be_created"   : self.IntermediateDirectoryList,
            "dependent_library_build_directory" : self.LibraryBuildDirectoryList,
            #"dependent_library_makefile"        : [path.join(bdir, makefileName) for bdir in self.LibraryBuildDirectoryList],
            "object_build_target"               : self.ObjectBuildTargetList,
            "build_type"                        : self.BuildType,
        }
        
        self.PrepareDirectory()
        
        autoGenMakefile = AutoGenString()
        autoGenMakefile.Append(gModuleMakefileTemplate, makefileTemplateDict)
        #print autoGenMakefile.String
        
        filePath = ""
        if file == None:
            filePath = path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.MakefileDir, makefileName)
        else:
            filePath = file

        self.SaveFile(filePath, str(autoGenMakefile))
        return filePath

    def SaveFile(self, file, content):
        f = None
        if os.path.exists(file):
            f = open(file, 'r')
            if content == f.read():
                f.close()
                return
            f.close()
        f = open(file, "w")
        f.write(content)
        f.close()

    def ProcessSourceFileList(self, makeType=gMakeType):
        rule = self.PlatformInfo.BuildRule

        self.BuildFileList = []
        self.ObjectFileList = []
        self.ObjectBuildTargetList = []
        self.AutoGenBuildFileList = []
        self.IntermediateDirectoryList = []

        for f in self.ModuleInfo.AutoGenFileList:
            name = path.basename(f)
            base, ext = path.splitext(name)

            ftype = rule.FileTypeMapping[ext]
            if ftype not in rule.Makefile[makeType]:
                continue

            ftype = "AutoGen-Code"
            self.AutoGenBuildFileList.append(f)
            #self.BuildFileList.append(name)
            self.ObjectFileList.append(base + ".obj")
            
            autoGen = AutoGenString()
            autoGen.Append(rule.Makefile[makeType][ftype],
                           {"fdir":".", "fbase":base, "fext":ext, "fname":name, "sep":os.path.sep,
                            "dep":self.GetDependencyList(os.path.join(self.ModuleInfo.DebugDir, f), self.ModuleInfo.IncludePathList)})
            self.ObjectBuildTargetList.append(autoGen.String)

        fileList = self.ModuleInfo.SourceFileList
        for f in fileList:
            name = path.basename(f)
            base, ext = path.splitext(name)
            basedir = path.dirname(f)
            if basedir == "":
                basedir = "."
            elif basedir not in self.IntermediateDirectoryList:
                self.IntermediateDirectoryList.append(basedir)
            if base.endswith("Gcc"):
                continue
            
            ftype = rule.FileTypeMapping[ext]
            if ftype not in rule.Makefile[makeType]:
                continue

            self.BuildFileList.append(f)
            # CreateDirectory(path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.OutputDir, basedir))
            self.ObjectFileList.append(basedir + gDirectorySeparator[makeType] + base + ".obj")
            
            autoGen = AutoGenString()
            autoGen.Append(rule.Makefile[makeType][ftype],
                           {"fdir":basedir, "fbase":base, "fext":ext, "fname":name, "sep":gDirectorySeparator[makeType],
                           "dep":self.GetDependencyList(os.path.join(self.ModuleInfo.SourceDir, f), self.ModuleInfo.IncludePathList)
                           })
            self.ObjectBuildTargetList.append(autoGen.String)

        self.FileDependency = self.GetFileDependency()

    def ProcessDependentLibrary(self, makeType=gMakeType):
        for libm in self.ModuleInfo.DependentLibraryList:
            libf = str(libm)
            libp = path.dirname(libf)
            base = path.basename(libf).split(".")[0]
            self.LibraryBuildDirectoryList.append(libp + gDirectorySeparator[makeType] + base)
            self.LibraryFileList.append(libm.BaseName + ".lib")

    def GetPlatformBuildDirectory(self):
        if os.path.isabs(self.PlatformInfo.OutputDir):
            return self.PlatformInfo.OutputDir
        else:
            return os.path.join("$(WORKSPACE_DIR)", self.PlatformInfo.OutputDir)

    def GetAutoGeneratedFileList(self):
        if self.ModuleInfo.IsLibrary:
            return ""
        else:
            return "AutoGen.c"

    def GetFileDependency(self):
        cwd = os.getcwd()
        os.chdir(self.ModuleInfo.WorkspaceDir)
        dependency = {}
        for f in self.BuildFileList:
            f = os.path.join(self.ModuleInfo.SourceDir, f)
            dependency[f] = self.GetDependencyList(f, self.ModuleInfo.IncludePathList)
        os.chdir(cwd)
        return dependency

    def GetDependencyList(self, file, searchPathList):
        cwd = os.getcwd()
        os.chdir(self.ModuleInfo.WorkspaceDir)

        fileStack = [file]
        dependencyList = []
        while len(fileStack) > 0:
            f = fileStack.pop()

            currentFileDependencyList = []
            if f in gDependencyDatabase:
                currentFileDependencyList = gDependencyDatabase[f]
                #print "@@@@@@",f,"is in dependency database"
                for dep in currentFileDependencyList:
                    if dep not in fileStack:
                        fileStack.append(dep)
            else:
                fd = open(f, 'r')
                fileContent = fd.read()
                fd.close()
                if fileContent[0] == 0xff or fileContent[0] == 0xfe:
                    fileContent = unicode(fileContent, "utf-16")
                includedFileList = gIncludePattern.findall(fileContent)

                currentFilePath = os.path.dirname(f)
                for inc in includedFileList:
                    inc = os.path.normpath(inc)
                    for searchPath in [currentFilePath] + searchPathList:
                        filePath = os.path.join(searchPath, inc)
                        #print "   @@@",filePath
                        if not os.path.exists(filePath) or filePath in currentFileDependencyList:
                            continue
                        currentFileDependencyList.append(filePath)
                        if filePath not in fileStack:
                            fileStack.append(filePath)
                        break
                    #else:
                    #    print "###", inc, "was not found in any given path:",f,"\n   ", "\n    ".join(searchPathList)
                gDependencyDatabase[f] = currentFileDependencyList
            dependencyList.extend(currentFileDependencyList)
        dependencyList = list(set(dependencyList))  # remove duplicate ones

        os.chdir(cwd)
        dependencyList.append(file)
        return dependencyList


# This acts like the main() function for the script, unless it is 'import'ed into another
# script.
if __name__ == '__main__':
    print "Running Operating System =", sys.platform
    ewb = WorkspaceBuild()
    #print ewb.Build.keys()
    
    myArch = ewb.Build["IA32"].Arch
    #print myArch

    myBuild = ewb.Build["IA32"]
    
    myWorkspace = ewb
    apf = ewb.TargetTxt.TargetTxtDictionary["ACTIVE_PLATFORM"][0]
    myPlatform = myBuild.PlatformDatabase[os.path.normpath(apf)]

    for mf in myBuild.ModuleDatabase:
        #mf = "MdePkg\\Library\\BaseLib\\BaseLib.inf"
        #if mf in myPlatform.Modules and mf in myBuild.ModuleDatabase:
        #print mf

        myModule = myBuild.ModuleDatabase[mf]

        myPackage = FindModuleOwner(myModule.DescFilePath, myBuild.PackageDatabase)

        myToolchain = ewb.TargetTxt.TargetTxtDictionary["TOOL_CHAIN_TAG"][0]
        #print myToolchain

        myBuildTarget = ewb.TargetTxt.TargetTxtDictionary["TARGET"][0]
        #print myBuildTarget

        myBuildOption = {
            "ENABLE_PCH"        :   False,
            "ENABLE_LOCAL_LIB"  :   True,
        }

        myMakefile = Makefile(myModule, myPackage, myPlatform, myWorkspace, myToolchain, myBuildTarget,
                              myArch, myBuildOption, "nmake")

        myMakefile.NewGenerate()
