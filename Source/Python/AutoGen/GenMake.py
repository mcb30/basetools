## @file
# Create makefile for MS nmake and GNU make
#
# Copyright (c) 2007, Intel Corporation
# All rights reserved. This program and the accompanying materials
# are licensed and made available under the terms and conditions of the BSD License
# which accompanies this distribution.  The full text of the license may be found at
# http://opensource.org/licenses/bsd-license.php
#
# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
#

## Import Modules
#
import os
import sys
import string
import re
import os.path as path

from Common.EdkIIWorkspaceBuild import *
from Common.EdkIIWorkspace import *
from Common.BuildToolError import *
from Common.Misc import *
from BuildInfo import *
from BuildEngine import *

gIncludePattern = re.compile("^[ #]*include[ ]+[\"<]*([^\"< >]+)[>\" ]*$", re.MULTILINE | re.UNICODE)
gMacroPattern = re.compile("[_A-Z][_A-Z0-9]*\(.+\)", re.UNICODE)

gMakefileHeader = '''#
# DO NOT EDIT
# This file is auto-generated by build utility
#
# Module Name:
#
#   %s
#
# Abstract:
#
#   Auto-generated makefile for building modules and libraries
#
'''

gLibraryMakeCommand = '''cd %(makedir)s
\t$(MAKE) $(MAKE_FLAGS) %(target)s
\tcd $(MODULE_BUILD_DIR)'''

gMakeType = ""
if sys.platform == "win32":
    gMakeType = "nmake"
else:
    gMakeType = "gmake"

gMakefileName = {"nmake" : "Makefile", "gmake" : "GNUmakefile"}

gDirectorySeparator = {"nmake" : "\\", "gmake" : "/"}

gCreateDirectoryCommand = {"nmake" : "mkdir", "gmake" : "mkdir -p"}
gRemoveDirectoryCommand = {"nmake" : "rmdir /s /q", "gmake" : "rm -r -f"}
gRemoveFileCommand = {"nmake" : "del /f /q", "gmake" : "rm -f"}
gCopyFileCommand = {"nmake" : "copy /y", "gmake" : "cp -f"}
gCreateDirectoryCommandTemplate = {"nmake" : 'if not exist %(dir)s mkdir %(dir)s',
                                   "gmake" : "test ! -e %(dir)s && mkdir -p %(dir)s"}
gRemoveDirectoryCommandTemplate = {"nmake" : 'if exist %(dir)s rmdir /s /q %(dir)s',
                                   "gmake" : "test -e %(dir)s && rm -r -f %(dir)s"}

#   $(CP)     copy file command
#   $(MV)     move file command
#   $(RM)     remove file command
#   $(MD)     create dir command
#   $(RD)     remove dir command
#
#   $(TCP)     copy file if destination file doesn't exist
#   $(TMV)     move file if destination file doesn't exist
#   $(TRM)     remove file if destination file exists
#   $(TMD)     create dir if destination dir doesn't exist
#   $(TRD)     remove dir if destination dir exists
gShellCommand = {
    "nmake" : {
        "CP"    :   "copy /y",
        "MV"    :   "move /y",
        "RM"    :   "del /f /q",
        "MD"    :   "mkdir",
        "RD"    :   "rmdir /s /q",
    },

    "gmake" : {
        "CP"    :   "cp -f",
        "MV"    :   "mv -f",
        "RM"    :   "rm -f",
        "MD"    :   "mkdir -p",
        "RD"    :   "rm -r -f",
    }
}
gIncludeFlag = {"MSFT" : "/I", "GCC" : "-I", "INTEL" : "-I"}

gStartGroupFlag = {"MSFT" : "", "GCC" : "-(", "INTEL" : ""}
gEndGroupFlag = {"MSFT" : "", "GCC" : "-)", "INTEL" : ""}

gCustomMakefileTemplate = '''
${makefile_header}

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}
PLATFORM_RELATIVE_DIR = ${platform_relative_directory}
PLATFORM_DIR = $(WORKSPACE)${separator}${platform_relative_directory}
PLATFORM_OUTPUT_DIR = ${platform_output_directory}

#
# Module Macro Definition
#
MODULE_NAME = ${module_name}
MODULE_GUID = ${module_guid}
MODULE_VERSION = ${module_version}
MODULE_TYPE = ${module_type}
MODULE_FILE_BASE_NAME = ${module_file_base_name}
BASE_NAME = $(MODULE_NAME)
MODULE_RELATIVE_DIR = ${module_relative_directory}
MODULE_DIR = $(WORKSPACE)${separator}${module_relative_directory}

#
# Build Configuration Macro Definition
#
ARCH = ${architecture}
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}

#
# Build Directory Macro Definition
#
PLATFORM_BUILD_DIR = ${platform_build_directory}
BUILD_DIR = ${platform_build_directory}${separator}${build_target}_${toolchain_tag}
BIN_DIR = $(BUILD_DIR)${separator}${architecture}
LIB_DIR = $(BIN_DIR)
MODULE_BUILD_DIR = $(BUILD_DIR)${separator}${architecture}${separator}${module_relative_directory}${separator}${module_file_base_name}
OUTPUT_DIR = $(MODULE_BUILD_DIR)${separator}OUTPUT
DEBUG_DIR = $(MODULE_BUILD_DIR)${separator}DEBUG
DEST_DIR_OUTPUT = $(OUTPUT_DIR)
DEST_DIR_DEBUG = $(DEBUG_DIR)

#
# Default Tools Flags Macro Definition (from tools_def.txt by default)
#
${BEGIN}DEFAULT_${tool_code}_FLAGS = ${default_tool_flags}
${END}

#
# Platform Tools Flags Macro Definition (from platform description file)
#
${BEGIN}PLATFORM_${tool_code}_FLAGS = ${platform_tool_flags}
${END}

#
# Platform Tools Flags Macro Definition (from platform description file)
#
${BEGIN}MODULE_${tool_code}_FLAGS = ${module_tool_flags}
${END}

#
# ToolsFlagMacro
#
${BEGIN}${tool_code}_FLAGS = $(DEFAULT_${tool_code}_FLAGS) $(PLATFORM_${tool_code}_FLAGS) $(MODULE_${tool_code}_FLAGS)
${END}
MAKE_FLAGS = /nologo

#
# ToolsPathMacro
#
${BEGIN}${tool_code} = ${tool_path}
${END}

${custom_makefile_content}

#
# Target used when called from platform makefile, which will bypass the build of dependent libraries
#

pbuild: init all


#
# Target used for library build, which will bypass the build of dependent libraries
#

lbuild: init all


#
# ModuleTarget
#

mbuild: init all


#
# Initialization target: print build information and create necessary directories
#
init:
\t-@echo Building ... $(MODULE_NAME) $(MODULE_VERSION) [$(ARCH)] in platform $(PLATFORM_NAME) $(PLATFORM_VERSION)
\t${BEGIN}@${create_directory_command}
\t${END}

'''

gModuleMakefileTemplate = '''
${makefile_header}

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}
PLATFORM_RELATIVE_DIR = ${platform_relative_directory}
PLATFORM_DIR = $(WORKSPACE)${separator}${platform_relative_directory}
PLATFORM_OUTPUT_DIR = ${platform_output_directory}

#
# Module Macro Definition
#
MODULE_NAME = ${module_name}
MODULE_GUID = ${module_guid}
MODULE_VERSION = ${module_version}
MODULE_TYPE = ${module_type}
MODULE_FILE_BASE_NAME = ${module_file_base_name}
BASE_NAME = $(MODULE_NAME)
MODULE_RELATIVE_DIR = ${module_relative_directory}
MODULE_DIR = $(WORKSPACE)${separator}${module_relative_directory}

#
# Build Configuration Macro Definition
#
ARCH = ${architecture}
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}

#
# Build Directory Macro Definition
#
PLATFORM_BUILD_DIR = ${platform_build_directory}
BUILD_DIR = ${platform_build_directory}${separator}${build_target}_${toolchain_tag}
BIN_DIR = $(BUILD_DIR)${separator}${architecture}
LIB_DIR = $(BIN_DIR)
MODULE_BUILD_DIR = $(BUILD_DIR)${separator}${architecture}${separator}${module_relative_directory}${separator}${module_file_base_name}
OUTPUT_DIR = $(MODULE_BUILD_DIR)${separator}OUTPUT
DEBUG_DIR = $(MODULE_BUILD_DIR)${separator}DEBUG
DEST_DIR_OUTPUT = $(OUTPUT_DIR)
DEST_DIR_DEBUG = $(DEBUG_DIR)

#
# Default Tools Flags Macro Definition (from tools_def.txt by default)
#
${BEGIN}DEFAULT_${tool_code}_FLAGS = ${default_tool_flags}
${END}

#
# Platform Tools Flags Macro Definition (from platform description file)
#
${BEGIN}PLATFORM_${tool_code}_FLAGS = ${platform_tool_flags}
${END}

#
# Module Tools Flags Macro Definition (from platform/module description file)
#
${BEGIN}MODULE_${tool_code}_FLAGS = ${module_tool_flags}
${END}

#
# Tools Flag Macro
#
${BEGIN}${tool_code}_FLAGS = $(DEFAULT_${tool_code}_FLAGS) $(PLATFORM_${tool_code}_FLAGS) $(MODULE_${tool_code}_FLAGS)
${END}
MAKE_FLAGS = /nologo

#
# Tools Path Macro
#
${BEGIN}${tool_code} = ${tool_path}
${END}

#
# Shell Command Macro
#
${BEGIN}${shell_command_code} = ${shell_command}
${END}

#
# Build Macro
#
${BEGIN}${source_file_macro}
${END}

${BEGIN}${target_file_macro}
${END}

SOURCE_FILES = ${BEGIN}${source_file_macro_name} ${END}

TARGET_FILES = ${BEGIN}${target_file_macro_name} ${END}

INC = ${BEGIN}${include_path_prefix}$(WORKSPACE)${separator}${include_path} \\
      ${END}

#OBJECTS = ${BEGIN}$(OUTPUT_DIR)${separator}${object_file} \\
#          ${END}

LIBS = ${BEGIN}$(BUILD_DIR)${separator}$(ARCH)${separator}${library_file} \\
       ${END}${BEGIN}${system_library} \\
       ${END}

COMMON_DEPS = ${BEGIN}$(WORKSPACE)${separator}${common_dependency_file} \\
              ${END}

ENTRYPOINT = ${module_entry_point}

#
# Overridable Target Macro Definitions
#
INIT_TARGET = init
PCH_TARGET =
CODA_TARGET = ${BEGIN}${remaining_build_target} \\
              ${END}

#
# Default target, which will build dependent libraries in addition to source files
#

all: ${build_type}


#
# Target used when called from platform makefile, which will bypass the build of dependent libraries
#

pbuild: $(INIT_TARGET) $(PCH_TARGET) $(CODA_TARGET)

#
# ModuleTarget
#

mbuild: $(INIT_TARGET) gen_libs $(PCH_TARGET) $(CODA_TARGET)


#
# Target to update the FD
#

fds: mbuild gen_fds

#
# Initialization target: print build information and create necessary directories
#
init:
\t-@echo Building ... $(MODULE_NAME) $(MODULE_VERSION) [$(ARCH)] in platform $(PLATFORM_NAME) $(PLATFORM_VERSION)
\t${BEGIN}@${create_directory_command}
\t${END}

#
# GenLibsTarget
#
gen_libs:
\t${BEGIN}cd $(BUILD_DIR)${separator}$(ARCH)${separator}${dependent_library_build_directory}
\t$(MAKE) $(MAKE_FLAGS)
\t${END}cd $(MODULE_BUILD_DIR)

#
# Build Flash Device Image
#
gen_fds:
\tcd $(BUILD_DIR)
\t$(MAKE) $(MAKE_FLAGS) fds
\tcd $(MODULE_BUILD_DIR)

#
# Individual Object Build Targets
#
${BEGIN}${file_build_target}
${END}


#
# clean all intermediate files
#

clean:
\t${BEGIN}${clean_command}
\t${END}

#
# clean all generated files
#

cleanall:
\t${BEGIN}${cleanall_command}
\t${END}${remove_file_command} *.pdb *.idb > NUL 2>&1

#
# clean pre-compiled header files
#

cleanpch:
\t${remove_file_command} $(OUTPUT_DIR)\*.pch > NUL 2>&1

#
# clean all dependent libraries built
#

cleanlib:
\t${BEGIN}cd $(BUILD_DIR)${separator}$(ARCH)${separator}${dependent_library_build_directory}
\t$(MAKE) $(MAKE_FLAGS) cleanall
\t${END}cd $(MODULE_BUILD_DIR)

'''

gPlatformMakefileTemplate = '''
${makefile_header}

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}
PLATFORM_DIR = $(WORKSPACE)${separator}${platform_relative_directory}
PLATFORM_OUTPUT_DIR = ${platform_output_directory}

#
# Build Configuration Macro Definition
#
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}
MAKE_FLAGS = /nologo

#
# Build Directory Macro Definition
#
BUILD_DIR = ${platform_build_directory}${separator}${build_target}_${toolchain_tag}
FV_DIR = ${platform_build_directory}${separator}${build_target}_${toolchain_tag}${separator}FV

#
# Default target
#
all: init build_libraries build_modules build_fds

#
# Initialization target: print build information and create necessary directories
#
init:
\t-@echo Building ... $(PLATFORM_NAME) $(PLATFORM_VERSION) [${build_architecture_list}]
\t${BEGIN}@${create_directory_command}
\t${END}
#
# library build target
#
libraries: init build_libraries

#
# module build target
#
modules: init build_libraries build_modules

#
# Flash Device Image Target
#
fds: init build_fds

#
# Build all libraries:
#
build_libraries:
\t${BEGIN}cd $(WORKSPACE)${separator}${library_build_directory}
\t$(MAKE) $(MAKE_FLAGS) pbuild
\t${END}cd $(BUILD_DIR)

#
# Build all modules:
#
build_modules:
\t${BEGIN}cd $(WORKSPACE)${separator}${module_build_directory}
\t$(MAKE) $(MAKE_FLAGS) pbuild
\t${END}cd $(BUILD_DIR)

#
# Build Flash Device Image
#
build_fds:
\t-@echo Generating flash image, if any ...
${BEGIN}\tGenFds -f ${fdf_file} -o $(BUILD_DIR) -p ${active_platform} -a ${build_architecture_list}${END}${BEGIN} -r ${fd} ${END}${BEGIN} -i ${fv} ${END}

#
# run command for emulator platform only
#
run:
\tcd $(BUILD_DIR)${separator}IA32
\tSecMain
\tcd $(BUILD_DIR)

#
# Clean intermediate files
#
clean:
\t${BEGIN}cd $(WORKSPACE)${separator}${library_build_directory}
\t$(MAKE) $(MAKE_FLAGS) clean
\t${END}${BEGIN}cd $(WORKSPACE)${separator}${module_build_directory}
\t$(MAKE) $(MAKE_FLAGS) clean
\t${END}cd $(BUILD_DIR)

#
# Clean all generated files except to makefile
#
cleanall:
\t${BEGIN}${cleanall_command}
\t${END}

#
# Clean all library files
#
cleanlib:
\t${BEGIN}cd $(WORKSPACE)${separator}${library_build_directory}
\t$(MAKE) $(MAKE_FLAGS) cleanall
\t${END}cd $(BUILD_DIR)

'''

class Makefile(object):
    def __init__(self, Info, Option):
        if isinstance(Info, ModuleBuildInfo):
            if Info == None or Info == "":
                raise AutoGenError(msg="No valid module found! Please check your build configuration!\n")
            self.ModuleInfo = Info
            self.PlatformInfo = Info.PlatformInfo
            self.ModuleBuild = True

            self.BuildType = "mbuild"
            self.BuildFileList = []
            self.TargetFileList = []
            self.ObjectFileList = []
            self.ObjectBuildTargetList = []

            self.FileDependency = []
            self.LibraryBuildCommandList = []
            self.LibraryFileList = []
            self.LibraryMakefileList = []
            self.LibraryBuildDirectoryList = []
            self.SystemLibraryList = []

        elif type(Info) == type({}):    # and isinstance(info, PlatformBuildInfo):
            if len(Info) <= 0:
                raise AutoGenError(msg="No buildable platform found! Please check your build configuration!\n")
            self.PlatformInfo = Info
            self.ModuleBuild = False
            self.ModuleBuildCommandList = []
            self.ModuleMakefileList = []
            self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()
            self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()
        else:
            raise AutoGenError(msg="Non-buildable item:%s" % str(Info))

        self.Opt = Option
        self.BuildWithPch = Option["ENABLE_PCH"]
        self.BuildWithLocalLib = Option["ENABLE_LOCAL_LIB"]
        self.IntermediateDirectoryList = []

    def PrepareDirectory(self):
        if self.ModuleBuild:
            CreateDirectory(path.join(self.ModuleInfo.WorkspaceDir, self.PlatformInfo.BuildDir))
            CreateDirectory(path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.BuildDir))
            CreateDirectory(path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.DebugDir))

    def Generate(self, File=None, MakeType=gMakeType):
        if self.ModuleBuild:
            return self.GenerateModuleMakefile(File, MakeType)
        else:
            return self.GeneratePlatformMakefile(File, MakeType)

    def GeneratePlatformMakefile(self, File=None, MakeType=gMakeType):
        Separator = gDirectorySeparator[MakeType]

        ArchList = self.PlatformInfo.keys()
        PlatformInfo = self.PlatformInfo.values()[0]
        ActivePlatform = PlatformInfo.Platform

        OutputDir = PlatformInfo.OutputDir
        if os.path.isabs(OutputDir):
            self.PlatformBuildDirectory = OutputDir
            CreateDirectory(self.PlatformBuildDirectory)
        else:
            self.PlatformBuildDirectory = "$(WORKSPACE)" + Separator + OutputDir
            CreateDirectory(os.path.join(PlatformInfo.WorkspaceDir, OutputDir))


        self.IntermediateDirectoryList = ["$(BUILD_DIR)%s%s" % (Separator, Arch) for Arch in self.PlatformInfo]
        self.IntermediateDirectoryList.append("$(FV_DIR)")

        # TRICK: for not generating GenFds call in makefile if no FDF file
        if PlatformInfo.FdfFile != None and PlatformInfo.FdfFile != "":
            FdfFileList = [PlatformInfo.FdfFile]
        else:
            FdfFileList = []

        MakefileName = gMakefileName[MakeType]
        MakefileTemplateDict = {
            "makefile_header"           : gMakefileHeader % MakefileName,
            "platform_name"             : PlatformInfo.Name,
            "platform_guid"             : PlatformInfo.Guid,
            "platform_version"          : PlatformInfo.Version,
            "platform_relative_directory": PlatformInfo.SourceDir,
            "platform_output_directory" : PlatformInfo.OutputDir,
            "platform_build_directory"  : self.PlatformBuildDirectory,

            "toolchain_tag"             : PlatformInfo.ToolChain,
            "build_target"              : PlatformInfo.BuildTarget,
            "build_architecture_list"   : ",".join(ArchList),
            "architecture"              : self.PlatformInfo.keys(),
            "separator"                 : Separator,
            "create_directory_command"  : self.GetCreateDirectoryCommand(self.IntermediateDirectoryList, MakeType),
            "remove_directory_command"  : gRemoveDirectoryCommand[MakeType],
            "remove_file_command"       : gRemoveFileCommand[MakeType],
            "cleanall_command"          : self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList, MakeType),
            "library_build_directory"   : self.LibraryBuildDirectoryList,
            "module_build_directory"    : self.ModuleBuildDirectoryList,
            "fdf_file"                  : FdfFileList,
            "active_platform"           : PlatformInfo.WorkspaceDir + Separator + ActivePlatform.DescFilePath,
            "fd"                        : PlatformInfo.FdTargetList,
            "fv"                        : PlatformInfo.FvTargetList
        }

        self.PrepareDirectory()

        AutoGenMakefile = TemplateString()
        AutoGenMakefile.Append(gPlatformMakefileTemplate, MakefileTemplateDict)

        FilePath = ""
        if File == None:
            FilePath = path.join(PlatformInfo.WorkspaceDir, PlatformInfo.MakefileDir, MakefileName)
        else:
            FilePath = File

        return SaveFileOnChange(FilePath, str(AutoGenMakefile))

    def GenerateModuleMakefile(self, File=None, MakeType=gMakeType):
        if MakeType in self.ModuleInfo.CustomMakefile and self.ModuleInfo.CustomMakefile[MakeType] != "":
            return self.GenerateCustomBuildMakefile(File, MakeType)

        Separator = gDirectorySeparator[MakeType]
        PlatformInfo = self.PlatformInfo

        if os.path.isabs(PlatformInfo.OutputDir):
            self.PlatformBuildDirectory = PlatformInfo.OutputDir
        else:
            self.PlatformBuildDirectory = "$(WORKSPACE)" + Separator + PlatformInfo.OutputDir

        self.ProcessSourceFileList(MakeType)
        self.ProcessDependentLibrary(MakeType)

        if "DLINK" in PlatformInfo.ToolStaticLib:
            EdkLogger.debug(EdkLogger.DEBUG_5, "Static library: " + PlatformInfo.ToolStaticLib["DLINK"])
            self.SystemLibraryList.append(PlatformInfo.ToolStaticLib["DLINK"])

        EntryPoint = "_ModuleEntryPoint"
        if self.ModuleInfo.Arch == "EBC":
            EntryPoint = "EfiStart"

        DefaultToolFlag = PlatformInfo.DefaultToolOption.values()
        if self.ModuleInfo.ModuleType == "USER_DEFINED":
            DefaultToolFlag = ["" for p in DefaultToolFlag]

        if "CC" not in PlatformInfo.ToolChainFamily:
            raise AutoGenError(msg="[CC] is not supported [%s, %s, %s]" % (self.ModuleInfo.BuildTarget,
                                    self.ModuleInfo.ToolChain, self.ModuleInfo.Arch))
        if  "DLINK" not in PlatformInfo.ToolChainFamily:
            raise AutoGenError(msg="[DLINK] is not supported [%s, %s, %s]" % (self.ModuleInfo.BuildTarget,
                                    self.ModuleInfo.ToolChain, self.ModuleInfo.Arch))

        if self.ModuleInfo.IsLibrary:
            self.ResultFileList = self.DestFileDatabase["Static-Library-File"]
        #elif self.BuildType == "obj":
        #    ResultFile = ""
        elif self.ModuleInfo.ModuleType == "USER_DEFINED":
            self.ResultFileList = self.DestFileDatabase["Dynamic-Library-File"]
            #ResultFile = "$(LLIB_FILE) $(DLL_FILE)"
        #else:
        #    ResultFile = "$(LLIB_FILE) $(DLL_FILE) $(EFI_FILE)"

        SourceFileMacroNameList = []
        SourceFileMacroList = [] # macro name = file list
        for FileType in self.SourceFileDatabase:
            Macro = "%s_LIST" % FileType.replace("-", "_").upper()
            SourceFileMacroNameList.append("$(%s)" % Macro)
            Template = TemplateString()
            Template.Append("%s = ${BEGIN}${source_file} \\\n\t${END}" % Macro,
                            {"source_file" : self.SourceFileDatabase[FileType]})
            SourceFileMacroList.append(str(Template))
        TargetFileMacroList = []
        TargetFileMacroNameList = []
        for FileType in self.DestFileDatabase:
            Macro = "%s_LIST" % FileType.replace("-", "_").upper()
            TargetFileMacroNameList.append("$(%s)" % Macro)
            Template = TemplateString()
            Template.Append("%s = ${BEGIN}${target_file} \\\n\t${END}" % Macro,
                            {"target_file" : self.DestFileDatabase[FileType]})
            TargetFileMacroList.append(str(Template))

        MakefileName = gMakefileName[MakeType]
        MakefileTemplateDict = {
            "makefile_header"           : gMakefileHeader % MakefileName,
            "platform_name"             : PlatformInfo.Name,
            "platform_guid"             : PlatformInfo.Guid,
            "platform_version"          : PlatformInfo.Version,
            "platform_relative_directory": PlatformInfo.SourceDir,
            "platform_output_directory" : PlatformInfo.OutputDir,

            "module_name"               : self.ModuleInfo.Name,
            "module_guid"               : self.ModuleInfo.Guid,
            "module_version"            : self.ModuleInfo.Version,
            "module_type"               : self.ModuleInfo.ModuleType,
            "module_file_base_name"     : self.ModuleInfo.FileBase,
            "module_relative_directory" : self.ModuleInfo.SourceDir,

            "architecture"              : self.ModuleInfo.Arch,
            "toolchain_tag"             : self.ModuleInfo.ToolChain,
            "build_target"              : self.ModuleInfo.BuildTarget,

            "platform_build_directory"  : self.PlatformBuildDirectory,

            "separator"                 : Separator,
            "default_tool_flags"        : DefaultToolFlag,
            "platform_tool_flags"       : [PlatformInfo.BuildOption[tool] for tool in PlatformInfo.ToolPath],
            "module_tool_flags"         : [self.ModuleInfo.BuildOption[tool] for tool in PlatformInfo.ToolPath],

            "tool_code"                 : PlatformInfo.ToolPath.keys(),
            "tool_path"                 : PlatformInfo.ToolPath.values(),

            "shell_command_code"        : gShellCommand[MakeType].keys(),
            "shell_command"             : gShellCommand[MakeType].values(),

            "module_entry_point"        : EntryPoint,
            #"auto_generated_file"       : self.AutoGenBuildFileList,
            "include_path_prefix"       : gIncludeFlag[PlatformInfo.ToolChainFamily["CC"]],
            "dlink_output_flag"         : PlatformInfo.OutputFlag["DLINK"],
            "slink_output_flag"         : PlatformInfo.OutputFlag["SLINK"],
            "start_group_flag"          : gStartGroupFlag[PlatformInfo.ToolChainFamily["DLINK"]],
            "end_group_flag"            : gEndGroupFlag[PlatformInfo.ToolChainFamily["DLINK"]],
            "include_path"              : self.ModuleInfo.IncludePathList,
            "target_file"               : self.TargetFileList,
            "object_file"               : self.ObjectFileList,
            "library_file"              : self.LibraryFileList,
            "remaining_build_target"    : self.ResultFileList,
            "system_library"            : self.SystemLibraryList,
            "common_dependency_file"    : self.CommonFileDependency,
            "create_directory_command"  : self.GetCreateDirectoryCommand(self.IntermediateDirectoryList, MakeType),
            "remove_directory_command"  : gRemoveDirectoryCommand[MakeType],
            "remove_file_command"       : gRemoveFileCommand[MakeType],
            "copy_file_command"         : gCopyFileCommand[MakeType],
            "clean_command"             : self.GetRemoveDirectoryCommand(["$(OUTPUT_DIR)"], MakeType),
            "cleanall_command"          : self.GetRemoveDirectoryCommand(["$(DEBUG_DIR)", "$(OUTPUT_DIR)"], MakeType),
            "dependent_library_build_directory" : self.LibraryBuildDirectoryList,
            #"file_build_target"               : self.BuildTargetList,
            "build_type"                        : self.BuildType,
            "source_file_macro"         : SourceFileMacroList,
            "target_file_macro"         : TargetFileMacroList,
            "source_file_macro_name"    : SourceFileMacroNameList,
            "target_file_macro_name"    : TargetFileMacroNameList,
            "file_build_target"         : self.BuildTargetList,
        }

        self.PrepareDirectory()

        AutoGenMakefile = TemplateString()
        AutoGenMakefile.Append(gModuleMakefileTemplate, MakefileTemplateDict)

        FilePath = ""
        if File == None:
            FilePath = path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.MakefileDir, MakefileName)
        else:
            FilePath = File

        return SaveFileOnChange(FilePath, str(AutoGenMakefile))

    def GenerateCustomBuildMakefile(self, File=None, MakeType=gMakeType):
        Separator = gDirectorySeparator[MakeType]

        if os.path.isabs(self.PlatformInfo.OutputDir):
            self.PlatformBuildDirectory = self.PlatformInfo.OutputDir
        else:
            self.PlatformBuildDirectory = "$(WORKSPACE)" + Separator + self.PlatformInfo.OutputDir

        CustomMakefile = open(os.path.join(self.ModuleInfo.WorkspaceDir, self .ModuleInfo.CustomMakefile[MakeType]), 'r').read()

        MakefileName = gMakefileName[MakeType]
        MakefileTemplateDict = {
            "makefile_header"           : gMakefileHeader % MakefileName,
            "platform_name"             : self.PlatformInfo.Name,
            "platform_guid"             : self.PlatformInfo.Guid,
            "platform_version"          : self.PlatformInfo.Version,
            "platform_relative_directory": self.PlatformInfo.SourceDir,
            "platform_output_directory" : self.PlatformInfo.OutputDir,

            "module_name"               : self.ModuleInfo.Name,
            "module_guid"               : self.ModuleInfo.Guid,
            "module_version"            : self.ModuleInfo.Version,
            "module_type"               : self.ModuleInfo.ModuleType,
            "module_file_base_name"     : self.ModuleInfo.FileBase,
            "module_relative_directory" : self.ModuleInfo.SourceDir,

            "architecture"              : self.ModuleInfo.Arch,
            "toolchain_tag"             : self.ModuleInfo.ToolChain,
            "build_target"              : self.ModuleInfo.BuildTarget,

            "platform_build_directory"  : self.PlatformBuildDirectory,

            "separator"                 : Separator,
            "default_tool_flags"        : self.PlatformInfo.DefaultToolOption.values(),
            "platform_tool_flags"       : self.PlatformInfo.BuildOption.values(),
            "module_tool_flags"         : self.ModuleInfo.BuildOption.values(),

            "tool_code"                 : self.PlatformInfo.ToolPath.keys(),
            "tool_path"                 : self.PlatformInfo.ToolPath.values(),

            "create_directory_command"  : self.GetCreateDirectoryCommand(self.IntermediateDirectoryList, MakeType),
            "directory_to_be_created"   : self.IntermediateDirectoryList,
            "dependent_library_build_directory" : self.LibraryBuildDirectoryList,
            "custom_makefile_content"   : CustomMakefile
        }

        self.PrepareDirectory()

        AutoGenMakefile = TemplateString()
        AutoGenMakefile.Append(gCustomMakefileTemplate, MakefileTemplateDict)

        FilePath = ""
        if File == None:
            FilePath = path.join(self.ModuleInfo.WorkspaceDir, self.ModuleInfo.MakefileDir, MakefileName)
        else:
            FilePath = File

        return SaveFileOnChange(FilePath, str(AutoGenMakefile))

    def ProcessSourceFileList(self, MakeType=gMakeType):
        Separator = gDirectorySeparator[MakeType]

        Family = self.PlatformInfo.ToolChainFamily["CC"]
        BuildRule = self.PlatformInfo.BuildRule

        self.ResultFileList = []
        #self.ObjectFileList = []
        #self.ObjectBuildTargetList = []
        #self.AutoGenBuildFileList = []
        self.IntermediateDirectoryList = ["$(DEBUG_DIR)", "$(OUTPUT_DIR)"]

        self.SourceFileDatabase = {}  # {file type : file path}
        self.DestFileDatabase = {}  # {file type : file path}
        self.FileBuildTargetList = [] # [(src, target string)]
        self.BuildTargetList = [] # [target string]
        self.PendingBuildTargetList = [] # [FileBuildRule objects]

        ForceIncludedFile = []
        SourceFileList = []

        FileList = self.ModuleInfo.SourceFileList
        if len(FileList) == 0:
            raise AutoGenError(msg="No files to be built in module [%s, %s, %s]:\n\t%s" % (self.ModuleInfo.BuildTarget,
                                    self.ModuleInfo.ToolChain, self.ModuleInfo.Arch, str(self.ModuleInfo.Module)))

        CCodeFlag = False
        for FileInfo in FileList:
            F, SrcFileType, SrcFileBuildRule = FileInfo
            if SrcFileType == "C-Code-File":
                CCodeFlag = True
            SrcFileName = path.basename(F)
            SrcFileBase, SrcFileExt = path.splitext(SrcFileName)
            SrcFileDir = path.dirname(F)
            if SrcFileDir == "":
                SrcFileDir = "."
            else:
                P = "$(OUTPUT_DIR)" + Separator + SrcFileDir
                if P not in self.IntermediateDirectoryList:
                    self.IntermediateDirectoryList.append(P)
            SrcFileRelativePath = os.path.join(self.ModuleInfo.SourceDir, F)

            SrcFile, ExtraSrcFileList, DstFile, CommandList = SrcFileBuildRule.Apply(F, self.ModuleInfo.SourceDir, Separator)

            if SrcFileType not in self.SourceFileDatabase:
                self.SourceFileDatabase[SrcFileType] = []
            self.SourceFileDatabase[SrcFileType].append(SrcFile)
            SourceFileList.append(SrcFileRelativePath)

            BuildTargetTemplate = "${BEGIN}%s : ${deps}\n"\
                                  "${END}\t%s\n" % (DstFile, "\n\t".join(CommandList))
            self.FileBuildTargetList.append((SrcFileRelativePath, BuildTargetTemplate))

            while True:
                # next target
                DstFileType, DstFileBuildRule = BuildRule.Get(SrcFileBuildRule.DestFileExt, Family)
                if DstFileType == None:
                    DstFileType = "Unknown-Type-File"

                if DstFileType  in self.SourceFileDatabase:
                    self.SourceFileDatabase[DstFileType].append(DstFile)
                else:
                    if DstFileType not in self.DestFileDatabase:
                        self.DestFileDatabase[DstFileType] = []
                    self.DestFileDatabase[DstFileType].append(DstFile)

                if DstFileBuildRule != None and DstFileBuildRule.IsMultipleInput:
                    if DstFileBuildRule not in self.PendingBuildTargetList:
                        self.PendingBuildTargetList.append(DstFileBuildRule)
                    break
                elif DstFileBuildRule == None or DstFileBuildRule.CommandList == []:
                    self.ResultFileList.append(DstFile)
                    break

                SrcFile, ExtraSrcFileList, DstFile, CommandList = DstFileBuildRule.Apply(DstFile, None, Separator)
                BuildTargetString = "%s : %s %s\n"\
                                    "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                self.FileBuildTargetList.append((SrcFile, BuildTargetString))
                SrcFileBuildRule = DstFileBuildRule

        # handle pending targets
        TempBuildTargetList = []
        while True:
            while len(self.PendingBuildTargetList) > 0:
                SrcFileBuildRule = self.PendingBuildTargetList.pop()
                SrcFileList = []
                for FileType in SrcFileBuildRule.SourceFileType:
                    if FileType not in self.SourceFileDatabase:
                        if FileType not in self.DestFileDatabase:
                            continue
                        else:
                            SrcFileList.extend(self.DestFileDatabase[FileType])
                    else:
                        SrcFileList.extend(self.SourceFileDatabase[FileType])
                SrcFile, ExtraSrcFileList, DstFile, CommandList = SrcFileBuildRule.Apply(SrcFileList, None, Separator)
                BuildTargetString = "%s : %s %s\n"\
                                    "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                self.FileBuildTargetList.append((SrcFile, BuildTargetString))

                # try to find next target
                while True:
                    DstFileType, DstFileBuildRule = BuildRule.Get(SrcFileBuildRule.DestFileExt, Family)
                    if DstFileType == None:
                        DstFileType = "Unknown-Type-File"

                    if DstFileType  in self.SourceFileDatabase:
                        self.SourceFileDatabase[DstFileType].append(DstFile)
                    else:
                        if DstFileType not in self.DestFileDatabase:
                            self.DestFileDatabase[DstFileType] = []
                        self.DestFileDatabase[DstFileType].append(DstFile)

                    if DstFileBuildRule != None and DstFileBuildRule.IsMultipleInput:
                        TempBuildTargetList.append(DstFileBuildRule)
                        break
                    elif DstFileBuildRule == None or DstFileBuildRule.CommandList == []:
                        self.ResultFileList.append(DstFile)
                        break

                    SrcFile, ExtraSrcFileList, DstFile, CommandList = DstFileBuildRule.Apply(DstFile, None, Separator)
                    BuildTargetString = "%s : %s %s\n"\
                                        "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                    self.FileBuildTargetList.append((SrcFile, BuildTargetString))
                    SrcFileBuildRule = DstFileBuildRule
            if len(TempBuildTargetList) == 0:
                break
            self.PendingBuildTargetList = TempBuildTargetList

        if CCodeFlag == True:
            for F in self.ModuleInfo.AutoGenFileList:
                SrcFileName = path.basename(F)
                SrcFileBase, SrcFileExt = path.splitext(SrcFileName)
                SrcFileDir = path.dirname(F)
                if SrcFileDir == "":
                    SrcFileDir = "."
                else:
                    P = "$(DEBUG_DIR)" + Separator + SrcFileDir
                    if P not in self.IntermediateDirectoryList:
                        self.IntermediateDirectoryList.append(P)

                SrcFileRelativePath = os.path.join(self.ModuleInfo.DebugDir, F)

                SrcFileType, SrcFileBuildRule = BuildRule.Get(SrcFileExt, Family)
                if SrcFileType != None and SrcFileType == "C-Header-File":
                    ForceIncludedFile.append(SrcFileRelativePath)
                if SrcFileBuildRule == None or SrcFileBuildRule.CommandList == []:
                    continue

                SrcFile, ExtraSrcFileList, DstFile, CommandList = SrcFileBuildRule.Apply(F, self.ModuleInfo.DebugDir, Separator)

                if SrcFileType not in self.SourceFileDatabase:
                    self.SourceFileDatabase[SrcFileType] = []
                self.SourceFileDatabase[SrcFileType].append(SrcFile)
                SourceFileList.append(SrcFileRelativePath)

                BuildTargetTemplate = "${BEGIN}%s : ${deps}\n"\
                                      "${END}\t%s\n" % (DstFile, "\n\t".join(CommandList))
                self.FileBuildTargetList.append((SrcFileRelativePath, BuildTargetTemplate))

                while True:
                    # next target
                    DstFileType, DstFileBuildRule = BuildRule.Get(SrcFileBuildRule.DestFileExt, Family)
                    if DstFileType == None:
                        DstFileType = "Unknown-Type-File"

                    if DstFileType  in self.SourceFileDatabase:
                        self.SourceFileDatabase[DstFileType].append(DstFile)
                    else:
                        if DstFileType not in self.DestFileDatabase:
                            self.DestFileDatabase[DstFileType] = []
                        self.DestFileDatabase[DstFileType].append(DstFile)

                    if DstFileBuildRule != None and DstFileBuildRule.IsMultipleInput:
                        if DstFileBuildRule not in self.PendingBuildTargetList:
                            self.PendingBuildTargetList.append(DstFileBuildRule)
                        break
                    elif DstFileBuildRule == None or DstFileBuildRule.CommandList == []:
                        self.ResultFileList.append(DstFile)
                        break

                    SrcFile, ExtraSrcFileList, DstFile, CommandList = DstFileBuildRule.Apply(DstFile, None, Separator)
                    BuildTargetString = "%s : %s %s\n"\
                                        "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                    self.FileBuildTargetList.append((SrcFile, BuildTargetString))
                    SrcFileBuildRule = DstFileBuildRule

        #
        # Search dependency file list for each source file
        #
        self.FileDependency = self.GetFileDependency(SourceFileList, ForceIncludedFile, self.ModuleInfo.IncludePathList)
        DepSet = None
        for File in self.FileDependency:
            # skipt AutoGen.c
            if File.endswith("AutoGen.c") or not File.endswith(".c"):
                continue
            elif DepSet == None:
                DepSet = set(self.FileDependency[File])
            else:
                DepSet &= set(self.FileDependency[File])
        # in case nothing in SourceFileList
        if DepSet == None:
            DepSet = set()
        #
        # Extract comman files list in the dependency files
        #
        self.CommonFileDependency = list(DepSet)
        for F in self.FileDependency:
            NewDepSet = set(self.FileDependency[F])
            NewDepSet -= DepSet
            if F.endswith("AutoGen.c") or not F.endswith(".c"):
                self.FileDependency[F] = [Separator.join(["$(WORKSPACE)", dep]) for dep in self.FileDependency[F]]
            else:
                self.FileDependency[F] = ["$(COMMON_DEPS)"] + [Separator.join(["$(WORKSPACE)", dep]) for dep in NewDepSet]

        for File, TargetTemplate in self.FileBuildTargetList:
            if File not in self.FileDependency:
                self.BuildTargetList.append(TargetTemplate)
                continue
            Template = TemplateString()
            Template.Append(TargetTemplate, {"deps" : self.FileDependency[File]})
            self.BuildTargetList.append(str(Template))

    def ProcessDependentLibrary(self, MakeType=gMakeType):
        for LibraryModule in self.ModuleInfo.DependentLibraryList:
            LibraryFile = str(LibraryModule)
            FileBase = path.basename(LibraryFile).split(".")[0]
            LibraryBuildPath = path.dirname(LibraryFile) + gDirectorySeparator[MakeType] + FileBase
            self.LibraryBuildDirectoryList.append(LibraryBuildPath)
            self.LibraryFileList.append(gDirectorySeparator[MakeType].join([LibraryBuildPath, "OUTPUT", LibraryModule.BaseName + ".lib"]))

    def GetPlatformBuildDirectory(self):
        if os.path.isabs(self.PlatformInfo.OutputDir):
            return self.PlatformInfo.OutputDir
        else:
            return os.path.join("$(WORKSPACE)", self.PlatformInfo.OutputDir)

    def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):
        WorkingDir = os.getcwd()
        os.chdir(self.ModuleInfo.WorkspaceDir)
        Dependency = {}
        for F in FileList:
            Dependency[F] = self.GetDependencyList(F, ForceInculeList, SearchPathList)
        os.chdir(WorkingDir)
        return Dependency

    def GetDependencyList(self, File, ForceList, SearchPathList):
        WorkingDir = os.getcwd()
        os.chdir(self.ModuleInfo.WorkspaceDir)

        EdkLogger.debug(EdkLogger.DEBUG_3, "Try to get dependency files for %s" % File)
        EdkLogger.debug(EdkLogger.DEBUG_2, "Including %s" % " ".join(ForceList))
        FileStack = [File] + ForceList
        DependencySet = set()
        MacroUsedByIncludedFile = False

        while len(FileStack) > 0:
            EdkLogger.debug(EdkLogger.DEBUG_2, "Stack %s" % "\n\t".join(FileStack))
            F = FileStack.pop()

            CurrentFileDependencyList = []
            if F in gDependencyDatabase and not IsChanged(F):
                CurrentFileDependencyList = gDependencyDatabase[F]
                for Dep in CurrentFileDependencyList:
                    if Dep not in FileStack and Dep not in DependencySet:
                        FileStack.append(Dep)
            else:
                try:
                    Fd = open(F, 'r')
                except:
                    raise AutoGenError(FILE_OPEN_FAILURE, name=F)

                FileContent = Fd.read()
                Fd.close()
                if len(FileContent) == 0:
                    continue

                if FileContent[0] == 0xff or FileContent[0] == 0xfe:
                    FileContent = unicode(FileContent, "utf-16")
                IncludedFileList = gIncludePattern.findall(FileContent)

                CurrentFilePath = os.path.dirname(F)
                for Inc in IncludedFileList:
                    Inc = os.path.normpath(Inc)
                    for SearchPath in [CurrentFilePath] + SearchPathList:
                        FilePath = os.path.join(SearchPath, Inc)
                        if not os.path.exists(FilePath) or FilePath in CurrentFileDependencyList:
                            continue
                        CurrentFileDependencyList.append(FilePath)
                        if FilePath not in FileStack and FilePath not in DependencySet:
                            FileStack.append(FilePath)
                        break
                    else:
                        if gMacroPattern.match(Inc) != None:
                            MacroUsedByIncludedFile = True
                        EdkLogger.verbose("%s included by %s was not found in any given path:\n\t%s" % (Inc, F, "\n\t".join(SearchPathList)))
                if not MacroUsedByIncludedFile:
                    if F == File:
                        CurrentFileDependencyList += ForceList
                    #
                    # Don't keep the file in cache if it uses macro in included file.
                    # So it will be scanned again if another file includes this file.
                    #
                    gDependencyDatabase[F] = CurrentFileDependencyList
            DependencySet.update(CurrentFileDependencyList)

        #
        # If there's macro used in included file, always build the file by
        # returning a empty dependency
        #
        if MacroUsedByIncludedFile:
            DependencyList = []
        else:
            DependencyList = list(DependencySet)  # remove duplicate ones
            DependencyList.append(File)

        os.chdir(WorkingDir)
        return DependencyList

    def GetModuleBuildDirectoryList(self):
        DirList = []
        for Arch in self.PlatformInfo:
            for ModuleAutoGen in self.PlatformInfo[Arch].ModuleAutoGenList:
                DirList.append(ModuleAutoGen.BuildInfo.BuildDir)
        return DirList

    def GetLibraryBuildDirectoryList(self):
        DirList = []
        for Arch in self.PlatformInfo:
            for LibraryAutoGen in self.PlatformInfo[Arch].LibraryAutoGenList:
                DirList.append(LibraryAutoGen.BuildInfo.BuildDir)
        return DirList

    def GetCreateDirectoryCommand(self, DirList, MakeType=gMakeType):
        return [gCreateDirectoryCommandTemplate[MakeType] % {'dir':Dir} for Dir in DirList]

    def GetRemoveDirectoryCommand(self, DirList, MakeType=gMakeType):
        return [gRemoveDirectoryCommandTemplate[MakeType] % {'dir':Dir} for Dir in DirList]

# This acts like the main() function for the script, unless it is 'import'ed into another script.
if __name__ == '__main__':
    pass
