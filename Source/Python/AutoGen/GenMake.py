## @file
# Create makefile for MS nmake and GNU make
#
# Copyright (c) 2007, Intel Corporation
# All rights reserved. This program and the accompanying materials
# are licensed and made available under the terms and conditions of the BSD License
# which accompanies this distribution.  The full text of the license may be found at
# http://opensource.org/licenses/bsd-license.php
#
# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
#

## Import Modules
#
import os
import sys
import string
import re
import os.path as path

from Common.EdkIIWorkspaceBuild import *
from Common.EdkIIWorkspace import *
from Common.BuildToolError import *
from Common.Misc import *
from BuildEngine import *
import Common.GlobalData as GlobalData

## Regular expression for finding header file inclusions
gIncludePattern = re.compile("^[ #]*include[ \t]+[\"<]*([^\"<>\n\r]+)[>\" ]*$", re.MULTILINE | re.UNICODE)

## Regular expression for matching macro used in header file inclusion
gMacroPattern = re.compile("([_A-Z][_A-Z0-9]*)[ \t]*\((.+)\)", re.UNICODE)

## pattern for include style in R8.x code
gProtocolDefinition = "Protocol/%(HeaderKey)s/%(HeaderKey)s.h"
gGuidDefinition = "Guid/%(HeaderKey)s/%(HeaderKey)s.h"
gArchProtocolDefinition = "ArchProtocol/%(HeaderKey)s/%(HeaderKey)s.h"
gPpiDefinition = "Ppi/%(HeaderKey)s/%(HeaderKey)s.h"
gIncludeMacroConversion = {
  "EFI_PROTOCOL_DEFINITION"         :   gProtocolDefinition,
  "EFI_GUID_DEFINITION"             :   gGuidDefinition,
  "EFI_ARCH_PROTOCOL_DEFINITION"    :   gArchProtocolDefinition,
  "EFI_PROTOCOL_PRODUCER"           :   gProtocolDefinition,
  "EFI_PROTOCOL_CONSUMER"           :   gProtocolDefinition,
  "EFI_PROTOCOL_DEPENDENCY"         :   gProtocolDefinition,
  "EFI_ARCH_PROTOCOL_PRODUCER"      :   gArchProtocolDefinition,
  "EFI_ARCH_PROTOCOL_CONSUMER"      :   gArchProtocolDefinition,
  "EFI_ARCH_PROTOCOL_DEPENDENCY"    :   gArchProtocolDefinition,
  "EFI_PPI_DEFINITION"              :   gPpiDefinition,
  "EFI_PPI_PRODUCER"                :   gPpiDefinition,
  "EFI_PPI_CONSUMER"                :   gPpiDefinition,
  "EFI_PPI_DEPENDENCY"              :   gPpiDefinition,
}

## default makefile type
gMakeType = ""
if sys.platform == "win32":
    gMakeType = "nmake"
else:
    gMakeType = "gmake"


## BuildFile class
#
#  This base class encapsules build file and its generation. It uses template to generate
#  the content of build file. The content of build file will be got from AutoGen objects.
#
class BuildFile(object):
    ## template used to generate the build file (i.e. makefile if using make)
    _TEMPLATE_ = ''

    ## default file name for each type of build file
    _FILE_NAME_ = {
        "nmake" :   "Makefile",
        "gmake" :   "GNUmakefile"
    }

    ## Fixed header string for makefile
    _MAKEFILE_HEADER = '''#
# DO NOT EDIT
# This file is auto-generated by build utility
#
# Module Name:
#
#   %s
#
# Abstract:
#
#   Auto-generated makefile for building modules, libraries or platform
#
    '''

    ## Header string for each type of build file
    _FILE_HEADER_ = {
        "nmake" :   _MAKEFILE_HEADER % _FILE_NAME_["nmake"],
        "gmake" :   _MAKEFILE_HEADER % _FILE_NAME_["gmake"]
    }

    ## shell commands which can be used in build file in the form of macro
    #   $(CP)     copy file command
    #   $(MV)     move file command
    #   $(RM)     remove file command
    #   $(MD)     create dir command
    #   $(RD)     remove dir command
    #
    _SHELL_CMD_ = {
        "nmake" : {
            "CP"    :   "copy /y",
            "MV"    :   "move /y",
            "RM"    :   "del /f /q",
            "MD"    :   "mkdir",
            "RD"    :   "rmdir /s /q",
        },

        "gmake" : {
            "CP"    :   "cp -f",
            "MV"    :   "mv -f",
            "RM"    :   "rm -f",
            "MD"    :   "mkdir -p",
            "RD"    :   "rm -r -f",
        }
    }

    ## directory separator
    _SEP_ = {
        "nmake" :   "\\",
        "gmake" :   "/"
    }

    ## directory creation template
    _MD_TEMPLATE_ = {
        "nmake" :   'if not exist %(dir)s $(MD) %(dir)s',
        "gmake" :   "$(MD) %(dir)s"
    }

    ## directory removal template
    _RD_TEMPLATE_ = {
        "nmake" :   'if exist %(dir)s $(RD) %(dir)s',
        "gmake" :   "$(RD) %(dir)s"
    }

    _INC_FLAG_ = {"MSFT" : "/I", "GCC" : "-I", "INTEL" : "-I"}

    _LIB_GROUP_START_ = {"MSFT" : "", "GCC" : "-(", "INTEL" : ""}
    _LIB_GROUP_END = {"MSFT" : "", "GCC" : "-)", "INTEL" : ""}

    ## Constructor of BuildFile
    #
    #   @param  AutoGenObject   Object of AutoGen class
    #
    def __init__(self, AutoGenObject):
        self._AutoGenObject = AutoGenObject
        self._FileType = gMakeType

    ## Create build file
    #
    #   @param  FileType    Type of build file. Only nmake and gmake are supported now.
    #
    #   @retval TRUE        The build file is created or re-created successfully
    #   @retval FALSE       The build file exists and is the same as the one to be generated
    #
    def Generate(self, FileType=gMakeType):
        if FileType not in self._FILE_NAME_:
            EdkLogger.error("build", PARAMETER_INVALID, "Invalid build type [%s]" % FileType,
                            ExtraData="[%s]" % str(self._AutoGenObject))
        self._FileType = FileType
        FileContent = TemplateString()
        FileContent.Append(self._TEMPLATE_, self._TemplateDict)

        FileName = self._FILE_NAME_[FileType]
        return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), str(FileContent))

    ## Return a list of directory creation command string
    #
    #   @param      DirList     The list of directory to be created
    #
    #   @retval     list        The directory creation command list
    #
    def GetCreateDirectoryCommand(self, DirList):
        return [self._MD_TEMPLATE_[self._FileType] % {'dir':Dir} for Dir in DirList]

    ## Return a list of directory removal command string
    #
    #   @param      DirList     The list of directory to be removed
    #
    #   @retval     list        The directory removal command list
    #
    def GetRemoveDirectoryCommand(self, DirList):
        return [self._RD_TEMPLATE_[self._FileType] % {'dir':Dir} for Dir in DirList]


## ModuleMakefile class
#
#  This class encapsules makefie and its generation for module. It uses template to generate
#  the content of makefile. The content of makefile will be got from ModuleAutoGen object.
#
class ModuleMakefile(BuildFile):
    ## template used to generate the makefile for module
    _TEMPLATE_ = '''\
${makefile_header}

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}
PLATFORM_RELATIVE_DIR = ${platform_relative_directory}
PLATFORM_DIR = $(WORKSPACE)${separator}${platform_relative_directory}
PLATFORM_OUTPUT_DIR = ${platform_output_directory}

#
# Module Macro Definition
#
MODULE_NAME = ${module_name}
MODULE_GUID = ${module_guid}
MODULE_VERSION = ${module_version}
MODULE_TYPE = ${module_type}
MODULE_FILE_BASE_NAME = ${module_file_base_name}
BASE_NAME = $(MODULE_NAME)
MODULE_RELATIVE_DIR = ${module_relative_directory}
MODULE_DIR = $(WORKSPACE)${separator}${module_relative_directory}

#
# Build Configuration Macro Definition
#
ARCH = ${architecture}
TOOLCHAIN = ${toolchain_tag}
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}

#
# Build Directory Macro Definition
#
# PLATFORM_BUILD_DIR = ${platform_build_directory}
BUILD_DIR = ${platform_build_directory}
BIN_DIR = $(BUILD_DIR)${separator}${architecture}
LIB_DIR = $(BIN_DIR)
MODULE_BUILD_DIR = $(BUILD_DIR)${separator}${architecture}${separator}${module_relative_directory}${separator}${module_file_base_name}
OUTPUT_DIR = $(MODULE_BUILD_DIR)${separator}OUTPUT
DEBUG_DIR = $(MODULE_BUILD_DIR)${separator}DEBUG
DEST_DIR_OUTPUT = $(OUTPUT_DIR)
DEST_DIR_DEBUG = $(DEBUG_DIR)

#
# Tools Flag Macro (from platform/module description file, tools_def.txt)
#
${BEGIN}${tool_code}_FLAGS = ${module_tool_flags}
${END}

#
# Tools Path Macro
#
${BEGIN}${tool_code} = ${tool_path}
${END}

MAKE_FILE = ${makefile_path}

#
# Shell Command Macro
#
${BEGIN}${shell_command_code} = ${shell_command}
${END}

#
# Build Macro
#
${BEGIN}${source_file_macro}
${END}

${BEGIN}${target_file_macro}
${END}

SOURCE_FILES = ${BEGIN}${source_file_macro_name} ${END}

TARGET_FILES = ${BEGIN}${target_file_macro_name} ${END}

INC = ${BEGIN}${include_path_prefix}${include_path} \\
      ${END}

#OBJECTS = ${BEGIN}$(OUTPUT_DIR)${separator}${object_file} \\
#          ${END}

LIBS = ${BEGIN}${library_file} \\
       ${END}${BEGIN}${system_library} \\
       ${END} \\
       $(LIB_LIST)

COMMON_DEPS = ${BEGIN}${common_dependency_file} \\
              ${END}

IMAGE_ENTRY_POINT = ${module_entry_point}
ENTRYPOINT = ${module_entry_point}

#
# Overridable Target Macro Definitions
#
FORCE_REBUILD = force_build
INIT_TARGET = init
PCH_TARGET =
CODA_TARGET = ${BEGIN}${remaining_build_target} \\
              ${END}

#
# Default target, which will build dependent libraries in addition to source files
#

all: mbuild


#
# Target used when called from platform makefile, which will bypass the build of dependent libraries
#

pbuild: $(INIT_TARGET) $(PCH_TARGET) $(CODA_TARGET)

#
# ModuleTarget
#

mbuild: $(INIT_TARGET) gen_libs $(PCH_TARGET) $(CODA_TARGET)

#
# Phony target which is used to force executing commands for a target
#
force_build:
\t-@

#
# Target to update the FD
#

fds: mbuild gen_fds

#
# Initialization target: print build information and create necessary directories
#
init:
\t-@echo Building ... $(MODULE_NAME) [$(ARCH)]
${BEGIN}\t-@${create_directory_command}\n${END}\
${BEGIN}\t-@${copy_autogen_h}\n${END}

#
# GenLibsTarget
#
gen_libs:
\t${BEGIN}@cd ${dependent_library_build_directory} && "$(MAKE)" $(MAKE_FLAGS)
\t${END}@cd $(MODULE_BUILD_DIR)

#
# Build Flash Device Image
#
gen_fds:
\t@cd $(BUILD_DIR) && "$(MAKE)" $(MAKE_FLAGS) fds
\t@cd $(MODULE_BUILD_DIR)

#
# Individual Object Build Targets
#
${BEGIN}${file_build_target}
${END}


#
# clean all intermediate files
#

clean:
\t${BEGIN}${clean_command}
\t${END}

#
# clean all generated files
#

cleanall:
${BEGIN}\t${cleanall_command}
${END}\t$(RM) *.pdb *.idb > NUL 2>&1
\t$(RM) $(BIN_DIR)${separator}$(MODULE_NAME).efi

#
# clean pre-compiled header files
#

cleanpch:
\t$(RM) $(OUTPUT_DIR)\*.pch > NUL 2>&1

#
# clean all dependent libraries built
#

cleanlib:
\t${BEGIN}@cd ${dependent_library_build_directory} && "$(MAKE)" $(MAKE_FLAGS) cleanall
\t${END}@cd $(MODULE_BUILD_DIR)\n'''

    ## Constructor of ModuleMakefile
    #
    #   @param  ModuleAutoGen   Object of ModuleAutoGen class
    #
    def __init__(self, ModuleAutoGen):
        BuildFile.__init__(self, ModuleAutoGen)
        self.PlatformInfo = self._AutoGenObject.PlatformInfo

        self.ResultFileList = []
        self.IntermediateDirectoryList = ["$(DEBUG_DIR)", "$(OUTPUT_DIR)"]

        self.SourceFileDatabase = {}        # {file type : file path}
        self.DestFileDatabase = {}          # {file type : file path}
        self.FileBuildTargetList = []       # [(src, target string)]
        self.BuildTargetList = []           # [target string]
        self.PendingBuildTargetList = []    # [FileBuildRule objects]
        self.CommonFileDependency = []

        self.FileDependency = []
        self.LibraryBuildCommandList = []
        self.LibraryFileList = []
        self.LibraryMakefileList = []
        self.LibraryBuildDirectoryList = []
        self.SystemLibraryList = []

    # Compose a dict object containing information used to do replacement in template
    def _CreateTemplateDict(self):
        if self._FileType not in self._SEP_:
            EdkLogger.error("build", PARAMETER_INVALID, "Invalid Makefile type [%s]" % self._FileType,
                            ExtraData="[%s]" % str(self._AutoGenObject))
        Separator = self._SEP_[self._FileType]

        # break build if no source files and binary files are found
        if len(self._AutoGenObject.SourceFileList) == 0 and len(self._AutoGenObject.BinaryFileDict) == 0:
            EdkLogger.error("build", AUTOGEN_ERROR, "No files to be built in module [%s, %s, %s]"
                            % (self._AutoGenObject.BuildTarget, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch),
                            ExtraData="[%s]" % str(self._AutoGenObject))
        # convert source files and binary files to build target
        if len(self._AutoGenObject.SourceFileList) > 0:
            self.ProcessSourceFileList()
        if len(self._AutoGenObject.BinaryFileDict) > 0:
            self.ProcessBinaryFileList()

        # convert dependent libaries to build command
        self.ProcessDependentLibrary()
        if self._AutoGenObject.Arch == "EBC":
            # EBC compiler always use "EfiStart" as entry point
            EntryPoint = "EfiStart"
        elif self._AutoGenObject.AutoGenVersion < 0x00010005 and len(self._AutoGenObject.Module.ModuleEntryPointList) > 0:
            # R8 modules use different entry point functions
            EntryPoint = self._AutoGenObject.Module.ModuleEntryPointList[0]
        else:
            # R9 modules always use "_ModuleEntryPoint" as entry point
            EntryPoint = "_ModuleEntryPoint"

        DefaultToolFlag = self.PlatformInfo.ToolOption.values()
        # USER_DEFINED modules should take care of tools definitions by its own
        if self._AutoGenObject.ModuleType == "USER_DEFINED":
            DefaultToolFlag = ["" for p in DefaultToolFlag]

        if "CC" not in self.PlatformInfo.ToolChainFamily:
            EdkLogger.error(
                "build",
                AUTOGEN_ERROR,
                "Tool [CC] is not supported [%s, %s, %s]" \
                    % (self._AutoGenObject.BuildTarget, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch),
                ExtraData="[%s]" % str(self._AutoGenObject))
        if  "DLINK" not in self.PlatformInfo.ToolChainFamily:
            EdkLogger.error(
                "build",
                AUTOGEN_ERROR,
                "Tool [DLINK] is not supported [%s, %s, %s]" \
                    % (self._AutoGenObject.BuildTarget, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch),
                ExtraData="[%s]" % str(self._AutoGenObject))

        if self._AutoGenObject.IsLibrary:
            if "STATIC-LIBRARY-FILE" in self.DestFileDatabase:
                self.ResultFileList = self.DestFileDatabase["STATIC-LIBRARY-FILE"]
        elif self._AutoGenObject.ModuleType == "USER_DEFINED":
            if "DYNAMIC-LIBRARY-FILE" in self.DestFileDatabase:
                self.ResultFileList = self.DestFileDatabase["DYNAMIC-LIBRARY-FILE"]
        if len(self.ResultFileList) == 0:
            EdkLogger.error("build", AUTOGEN_ERROR, "Nothing to build",
                            ExtraData="[%s]" % str(self._AutoGenObject))

        SourceFileMacroNameList = []
        SourceFileMacroList = [] # macro name = file list
        for FileType in self.SourceFileDatabase:
            Macro = "%s_LIST" % FileType.replace("-", "_").upper()
            SourceFileMacroNameList.append("$(%s)" % Macro)
            Template = TemplateString()
            Template.Append("%s = ${BEGIN}${source_file} \\\n\t${END}" % Macro,
                            {"source_file" : self.SourceFileDatabase[FileType]})
            SourceFileMacroList.append(str(Template))
        TargetFileMacroList = []
        TargetFileMacroNameList = []
        for FileType in self.DestFileDatabase:
            Macro = "%s_LIST" % FileType.replace("-", "_").upper()
            TargetFileMacroNameList.append("$(%s)" % Macro)
            Template = TemplateString()
            Template.Append("%s = ${BEGIN}${target_file} \\\n\t${END}" % Macro,
                            {"target_file" : self.DestFileDatabase[FileType]})
            TargetFileMacroList.append(str(Template))

        # R8 modules need <BaseName>StrDefs.h for string ID
        if self._AutoGenObject.AutoGenVersion < 0x00010005 and len(self._AutoGenObject.UnicodeFileList) > 0:
            AutoGenHeaderFile = os.path.join("$(DEBUG_DIR)", "AutoGen.h")
            StringHeaderFile = os.path.join("$(DEBUG_DIR)", "%sStrDefs.h" % self._AutoGenObject.Name)
            CopyAutoGenHeaderFile = ["$(CP) %s %s" % (AutoGenHeaderFile, StringHeaderFile)]
        else:
            CopyAutoGenHeaderFile = []

        MakefileName = self._FILE_NAME_[self._FileType]
        MakefileTemplateDict = {
            "makefile_header"           : self._FILE_HEADER_[self._FileType],
            "makefile_path"             : os.path.join("$(MODULE_BUILD_DIR)", MakefileName),
            "platform_name"             : self.PlatformInfo.Name,
            "platform_guid"             : self.PlatformInfo.Guid,
            "platform_version"          : self.PlatformInfo.Version,
            "platform_relative_directory": self.PlatformInfo.SourceDir,
            "platform_output_directory" : self.PlatformInfo.OutputDir,

            "module_name"               : self._AutoGenObject.Name,
            "module_guid"               : self._AutoGenObject.Guid,
            "module_version"            : self._AutoGenObject.Version,
            "module_type"               : self._AutoGenObject.ModuleType,
            "module_file_base_name"     : self._AutoGenObject.FileBase,
            "module_relative_directory" : self._AutoGenObject.SourceDir,

            "architecture"              : self._AutoGenObject.Arch,
            "toolchain_tag"             : self._AutoGenObject.ToolChain,
            "build_target"              : self._AutoGenObject.BuildTarget,

            "platform_build_directory"  : self.PlatformInfo.BuildDir,

            "separator"                 : Separator,
            "module_tool_flags"         : [self._AutoGenObject.BuildOption[tool] for tool in self.PlatformInfo.ToolPath],

            "tool_code"                 : self.PlatformInfo.ToolPath.keys(),
            "tool_path"                 : self.PlatformInfo.ToolPath.values(),

            "shell_command_code"        : self._SHELL_CMD_[self._FileType].keys(),
            "shell_command"             : self._SHELL_CMD_[self._FileType].values(),

            "module_entry_point"        : EntryPoint,
            "include_path_prefix"       : self._INC_FLAG_[self.PlatformInfo.ToolChainFamily["CC"]],
            "dlink_output_flag"         : self.PlatformInfo.OutputFlag["DLINK"],
            "slink_output_flag"         : self.PlatformInfo.OutputFlag["SLINK"],
            "start_group_flag"          : self._LIB_GROUP_START_[self.PlatformInfo.ToolChainFamily["DLINK"]],
            "end_group_flag"            : self._LIB_GROUP_END[self.PlatformInfo.ToolChainFamily["DLINK"]],
            "include_path"              : self._AutoGenObject.IncludePathList,
            "library_file"              : self.LibraryFileList,
            "remaining_build_target"    : self.ResultFileList,
            "system_library"            : self.SystemLibraryList,
            "common_dependency_file"    : self.CommonFileDependency,
            "create_directory_command"  : self.GetCreateDirectoryCommand(self.IntermediateDirectoryList),
            "clean_command"             : self.GetRemoveDirectoryCommand(["$(OUTPUT_DIR)"]),
            "cleanall_command"          : self.GetRemoveDirectoryCommand(["$(DEBUG_DIR)", "$(OUTPUT_DIR)"]),
            "dependent_library_build_directory" : self.LibraryBuildDirectoryList,
            "source_file_macro"         : SourceFileMacroList,
            "target_file_macro"         : TargetFileMacroList,
            "source_file_macro_name"    : SourceFileMacroNameList,
            "target_file_macro_name"    : TargetFileMacroNameList,
            "file_build_target"         : self.BuildTargetList,
            "copy_autogen_h"            : CopyAutoGenHeaderFile,
        }

        return MakefileTemplateDict

    ## Process source files to generate makefile targets and dependencies
    #
    #  The intermediate and final targets and dependencies are controlled by
    #  build rules in $(WORKSPACE)/Conf/build_rule.txt. The dependencies of source
    #  file are figured out by search included files in the source file.
    #
    def ProcessSourceFileList(self):
        Separator = self._SEP_[self._FileType]

        ForceIncludedFile = []
        SourceFileList = []
        ExtraDenpendencies = {}

        if "CC" not in self.PlatformInfo.ToolChainFamily:
            EdkLogger.error("build", AUTOGEN_ERROR, "No CC tool found",
                            ExtraData="[%s]" % str(self._AutoGenObject))
        Family = self.PlatformInfo.ToolChainFamily["CC"]
        BuildRule = self.PlatformInfo.BuildRule
        Arch = self._AutoGenObject.Arch
        BuildType = self._AutoGenObject.BuildType

        CCodeFlag = False
        FileList = self._AutoGenObject.SourceFileList
        SourceDir = os.path.join(self._AutoGenObject.WorkspaceDir, self._AutoGenObject.SourceDir)
        for FileInfo in FileList:
            F, SrcFileType, SrcFileBuildRule = FileInfo
            # no rule, no build
            if SrcFileBuildRule == None:
                continue
            if SrcFileType == "C-CODE-FILE":
                CCodeFlag = True
            SrcFileName = path.basename(F)
            SrcFileBase, SrcFileExt = path.splitext(SrcFileName)
            SrcFileDir = path.dirname(F)
            if SrcFileDir == "":
                SrcFileDir = "."
            else:
                P = "$(OUTPUT_DIR)" + Separator + SrcFileDir
                if P not in self.IntermediateDirectoryList:
                    self.IntermediateDirectoryList.append(P)
            SrcFileRelativePath = os.path.join(SourceDir, F)

            SrcFile, ExtraSrcFileList, DstFile, CommandList = SrcFileBuildRule.Apply(F, SourceDir, Separator)
            if SrcFileType not in self.SourceFileDatabase:
                self.SourceFileDatabase[SrcFileType] = []
            self.SourceFileDatabase[SrcFileType].append(SrcFile)
            SourceFileList.append(SrcFileRelativePath)
            ExtraDenpendencies[SrcFileRelativePath] = ExtraSrcFileList

            BuildTargetTemplate = "${BEGIN}%s : ${deps}\n"\
                                  "${END}\t%s\n" % (DstFile, "\n\t".join(CommandList))
            self.FileBuildTargetList.append((SrcFileRelativePath, BuildTargetTemplate))

            while True:
                # next target
                DstFileType, DstFileBuildRule = BuildRule[SrcFileBuildRule.DestFileExt, BuildType, Arch, Family]
                if DstFileType == None:
                    DstFileType = "UNKNOWN-TYPE-FILE"

                if DstFileType  in self.SourceFileDatabase:
                    self.SourceFileDatabase[DstFileType].append(DstFile)
                else:
                    if DstFileType not in self.DestFileDatabase:
                        self.DestFileDatabase[DstFileType] = []
                    self.DestFileDatabase[DstFileType].append(DstFile)

                if DstFileBuildRule != None and DstFileBuildRule.IsMultipleInput:
                    if DstFileBuildRule not in self.PendingBuildTargetList:
                        self.PendingBuildTargetList.append(DstFileBuildRule)
                    break
                elif DstFileBuildRule == None or len(DstFileBuildRule.CommandList) == 0:
                    self.ResultFileList.append(DstFile)
                    break

                SrcFile, ExtraSrcFileList, DstFile, CommandList = DstFileBuildRule.Apply(DstFile, None, Separator)
                BuildTargetString = "%s : %s %s\n"\
                                    "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                self.FileBuildTargetList.append((SrcFile, BuildTargetString))
                SrcFileBuildRule = DstFileBuildRule

        # handle pending targets
        TempBuildTargetList = []
        while True:
            while len(self.PendingBuildTargetList) > 0:
                SrcFileBuildRule = self.PendingBuildTargetList.pop()
                SrcFileList = []
                for FileType in SrcFileBuildRule.SourceFileType:
                    if FileType not in self.SourceFileDatabase:
                        if FileType not in self.DestFileDatabase:
                            continue
                        else:
                            SrcFileList.extend(self.DestFileDatabase[FileType])
                    else:
                        SrcFileList.extend(self.SourceFileDatabase[FileType])
                SrcFile, ExtraSrcFileList, DstFile, CommandList = SrcFileBuildRule.Apply(SrcFileList, None, Separator)
                BuildTargetString = "%s : %s %s\n"\
                                    "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                self.FileBuildTargetList.append((SrcFile, BuildTargetString))

                # try to find next target
                while True:
                    DstFileType, DstFileBuildRule = BuildRule[SrcFileBuildRule.DestFileExt, BuildType, Arch, Family]
                    if DstFileType == None:
                        DstFileType = "UNKNOWN-TYPE-FILE"

                    if DstFileType in self.SourceFileDatabase:
                        self.SourceFileDatabase[DstFileType].append(DstFile)
                    else:
                        if DstFileType not in self.DestFileDatabase:
                            self.DestFileDatabase[DstFileType] = []
                        self.DestFileDatabase[DstFileType].append(DstFile)

                    if DstFileBuildRule != None and DstFileBuildRule.IsMultipleInput:
                        TempBuildTargetList.append(DstFileBuildRule)
                        break
                    elif DstFileBuildRule == None or len(DstFileBuildRule.CommandList) == 0:
                        self.ResultFileList.append(DstFile)
                        break

                    SrcFile, ExtraSrcFileList, DstFile, CommandList = DstFileBuildRule.Apply(DstFile, None, Separator)
                    BuildTargetString = "%s : %s %s\n"\
                                        "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                    self.FileBuildTargetList.append((SrcFile, BuildTargetString))
                    SrcFileBuildRule = DstFileBuildRule
            if len(TempBuildTargetList) == 0:
                break
            self.PendingBuildTargetList = TempBuildTargetList

        # Build AutoGen files only if we have C source files
        if CCodeFlag == True:
            for F in self._AutoGenObject.AutoGenFileList:
                SrcFileName = path.basename(F)
                SrcFileBase, SrcFileExt = path.splitext(SrcFileName)
                SrcFileDir = path.dirname(F)
                if SrcFileDir == "":
                    SrcFileDir = "."
                else:
                    P = "$(DEBUG_DIR)" + Separator + SrcFileDir
                    if P not in self.IntermediateDirectoryList:
                        self.IntermediateDirectoryList.append(P)

                SrcFileRelativePath = os.path.join(self._AutoGenObject.DebugDir, F)

                SrcFileType, SrcFileBuildRule = BuildRule[SrcFileExt, BuildType, Arch, Family]
                if SrcFileType != None and SrcFileType == "C-HEADER-FILE":
                    ForceIncludedFile.append(SrcFileRelativePath)
                if SrcFileBuildRule == None or len(SrcFileBuildRule.CommandList) == 0:
                    continue

                SrcFile, ExtraSrcFileList, DstFile, CommandList = SrcFileBuildRule.Apply(F, self._AutoGenObject.DebugDir, Separator)

                if SrcFileType not in self.SourceFileDatabase:
                    self.SourceFileDatabase[SrcFileType] = []
                self.SourceFileDatabase[SrcFileType].append(SrcFile)
                SourceFileList.append(SrcFileRelativePath)
                ExtraDenpendencies[SrcFileRelativePath] = ExtraSrcFileList

                BuildTargetTemplate = "${BEGIN}%s : ${deps}\n"\
                                      "${END}\t%s\n" % (DstFile, "\n\t".join(CommandList))
                self.FileBuildTargetList.append((SrcFileRelativePath, BuildTargetTemplate))

                while True:
                    # next target
                    DstFileType, DstFileBuildRule = BuildRule[SrcFileBuildRule.DestFileExt, BuildType, Arch, Family]
                    if DstFileType == None:
                        DstFileType = "UNKNOWN-TYPE-FILE"

                    if DstFileType  in self.SourceFileDatabase:
                        self.SourceFileDatabase[DstFileType].append(DstFile)
                    else:
                        if DstFileType not in self.DestFileDatabase:
                            self.DestFileDatabase[DstFileType] = []
                        self.DestFileDatabase[DstFileType].append(DstFile)

                    if DstFileBuildRule != None and DstFileBuildRule.IsMultipleInput:
                        if DstFileBuildRule not in self.PendingBuildTargetList:
                            self.PendingBuildTargetList.append(DstFileBuildRule)
                        break
                    elif DstFileBuildRule == None or len(DstFileBuildRule.CommandList) == 0:
                        self.ResultFileList.append(DstFile)
                        break

                    SrcFile, ExtraSrcFileList, DstFile, CommandList = DstFileBuildRule.Apply(DstFile, None, Separator)
                    BuildTargetString = "%s : %s %s\n"\
                                        "\t%s\n" % (DstFile, SrcFile, " ".join(ExtraSrcFileList), "\n\t".join(CommandList))
                    self.FileBuildTargetList.append((SrcFile, BuildTargetString))
                    SrcFileBuildRule = DstFileBuildRule

        #
        # Search dependency file list for each source file
        #
        self.FileDependency = self.GetFileDependency(SourceFileList, ForceIncludedFile, self._AutoGenObject.IncludePathList)
        DepSet = None
        for File in self.FileDependency:
            if self.FileDependency[File] == []:
                self.FileDependency[File] = ['$(FORCE_REBUILD)']
            elif File in ExtraDenpendencies:
                self.FileDependency[File] += ExtraDenpendencies[File]
            # skip non-C files
            if (not File.endswith(".c") and not File.endswith(".C")) or File.endswith("AutoGen.c"):
                continue
            elif DepSet == None:
                DepSet = set(self.FileDependency[File])
            else:
                DepSet &= set(self.FileDependency[File])
        # in case nothing in SourceFileList
        if DepSet == None:
            DepSet = set()
        #
        # Extract comman files list in the dependency files
        #
        self.CommonFileDependency = list(DepSet)
        for File in self.FileDependency:
            # skip non-C files
            if (not File.endswith(".c") and not File.endswith(".C")) or File.endswith("AutoGen.c"):
                continue
            NewDepSet = set(self.FileDependency[File])
            NewDepSet -= DepSet
            self.FileDependency[File] = ["$(COMMON_DEPS)"] + list(NewDepSet)

        # EdkLogger.verbose("Files to be built in %s :\n\t %s\n" % (str(self._AutoGenObject), "\n\t".join(self.FileDependency.keys())))
        for File, TargetTemplate in self.FileBuildTargetList:
            if File not in self.FileDependency:
                self.BuildTargetList.append(TargetTemplate)
                continue
            Template = TemplateString()
            Template.Append(TargetTemplate, {"deps" : self.FileDependency[File]})
            self.BuildTargetList.append(str(Template))

    ## Process binary files to generate makefile targets and dependencies
    #
    # All binary files are just copied to $(OUTPUT_DIR)
    #
    def ProcessBinaryFileList(self):
        BinaryFiles = self._AutoGenObject.BinaryFileDict
        BuildTargetString = "%(dst)s : %(src)s\n"\
                            "\t$(CP) %(src)s %(dst)s\n"
        for FileType in BinaryFiles:
            if FileType not in self.DestFileDatabase:
                self.DestFileDatabase[FileType] = []
            for F in BinaryFiles[FileType]:
                Src = os.path.join("$(MODULE_DIR)", F)
                FileName = os.path.basename(F)
                Dst = os.path.join("$(OUTPUT_DIR)", FileName)
                self.DestFileDatabase[FileType].append(Dst)
                self.ResultFileList.append(Dst)
                self.BuildTargetList.append(BuildTargetString % {"dst":Dst, "src":Src})

    ## For creating makefile targets for dependent libraries
    def ProcessDependentLibrary(self):
        for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:
            self.LibraryBuildDirectoryList.append(LibraryAutoGen.BuildDir)
            self.LibraryFileList.append(os.path.join(LibraryAutoGen.OutputDir, LibraryAutoGen.Name + ".lib"))

    ## Return a list containing source file's dependencies
    #
    #   @param      FileList        The list of source files
    #   @param      ForceInculeList The list of files which will be included forcely
    #   @param      SearchPathList  The list of search path
    #
    #   @retval     dict            The mapping between source file path and its dependencies
    #
    def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):
        Dependency = {}
        for F in FileList:
            Dependency[F] = self.GetDependencyList(F, ForceInculeList, SearchPathList)
        return Dependency

    ## Find dependencies for one source file
    #
    #  By searching recursively "#include" directive in file, find out all the
    #  files needed by given source file. The dependecies will be only searched
    #  in given search path list.
    #
    #   @param      File            The source file
    #   @param      ForceInculeList The list of files which will be included forcely
    #   @param      SearchPathList  The list of search path
    #
    #   @retval     list            The list of files the given source file depends on
    #
    def GetDependencyList(self, File, ForceList, SearchPathList):
        EdkLogger.debug(EdkLogger.DEBUG_1, "Try to get dependency files for %s" % File)
        EdkLogger.debug(EdkLogger.DEBUG_0, "Including %s" % " ".join(ForceList))
        FileStack = [File] + ForceList
        DependencySet = set()
        MacroUsedByIncludedFile = False

        if self._AutoGenObject.Arch not in gDependencyDatabase:
            gDependencyDatabase[self._AutoGenObject.Arch] = {}
        DepDb = gDependencyDatabase[self._AutoGenObject.Arch]
        while len(FileStack) > 0:
            EdkLogger.debug(EdkLogger.DEBUG_0, "Stack %s" % "\n\t".join(FileStack))
            F = FileStack.pop()

            CurrentFileDependencyList = []
            if F in DepDb and not IsChanged(F):
                CurrentFileDependencyList = DepDb[F]
                for Dep in CurrentFileDependencyList:
                    if Dep not in FileStack and Dep not in DependencySet:
                        FileStack.append(Dep)
            else:
                try:
                    Fd = open(F, 'r')
                except:
                    EdkLogger.error("build", FILE_OPEN_FAILURE, ExtraData=F)

                FileContent = Fd.read()
                Fd.close()
                if len(FileContent) == 0:
                    continue

                if FileContent[0] == 0xff or FileContent[0] == 0xfe:
                    FileContent = unicode(FileContent, "utf-16")
                IncludedFileList = gIncludePattern.findall(FileContent)

                CurrentFilePath = os.path.dirname(F)
                for Inc in IncludedFileList:
                    # if there's macro used to reference header file, expand it
                    HeaderList = gMacroPattern.findall(Inc)
                    if len(HeaderList) == 1 and len(HeaderList[0]) == 2:
                        HeaderType = HeaderList[0][0]
                        HeaderKey = HeaderList[0][1]
                        if HeaderType in gIncludeMacroConversion:
                            Inc = gIncludeMacroConversion[HeaderType] % {"HeaderKey" : HeaderKey}
                        else:
                            # not known macro used in #include
                            MacroUsedByIncludedFile = True
                            continue
                    Inc = os.path.normpath(Inc)
                    for SearchPath in [CurrentFilePath] + SearchPathList:
                        FilePath = os.path.join(SearchPath, Inc)
                        if not os.path.exists(FilePath) or FilePath in CurrentFileDependencyList:
                            continue
                        CurrentFileDependencyList.append(FilePath)
                        if FilePath not in FileStack and FilePath not in DependencySet:
                            FileStack.append(FilePath)
                        break
                    else:
                        EdkLogger.verbose("%s included by %s was not found in any given path:\n\t%s" % (Inc, F, "\n\t".join(SearchPathList)))

                if not MacroUsedByIncludedFile:
                    if F == File:
                        CurrentFileDependencyList += ForceList
                    #
                    # Don't keep the file in cache if it uses macro in included file.
                    # So it will be scanned again if another file includes this file.
                    #
                    DepDb[F] = CurrentFileDependencyList
            DependencySet.update(CurrentFileDependencyList)

        #
        # If there's macro used in included file, always build the file by
        # returning a empty dependency
        #
        if MacroUsedByIncludedFile:
            DependencyList = []
        else:
            DependencyList = list(DependencySet)  # remove duplicate ones
            DependencyList.append(File)

        return DependencyList

    _TemplateDict = property(_CreateTemplateDict)

## CustomMakefile class
#
#  This class encapsules makefie and its generation for module. It uses template to generate
#  the content of makefile. The content of makefile will be got from ModuleAutoGen object.
#
class CustomMakefile(BuildFile):
    ## template used to generate the makefile for module with custom makefile
    _TEMPLATE_ = '''\
${makefile_header}

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}
PLATFORM_RELATIVE_DIR = ${platform_relative_directory}
PLATFORM_DIR = $(WORKSPACE)${separator}${platform_relative_directory}
PLATFORM_OUTPUT_DIR = ${platform_output_directory}

#
# Module Macro Definition
#
MODULE_NAME = ${module_name}
MODULE_GUID = ${module_guid}
MODULE_VERSION = ${module_version}
MODULE_TYPE = ${module_type}
MODULE_FILE_BASE_NAME = ${module_file_base_name}
BASE_NAME = $(MODULE_NAME)
MODULE_RELATIVE_DIR = ${module_relative_directory}
MODULE_DIR = $(WORKSPACE)${separator}${module_relative_directory}

#
# Build Configuration Macro Definition
#
ARCH = ${architecture}
TOOLCHAIN = ${toolchain_tag}
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}

#
# Build Directory Macro Definition
#
# PLATFORM_BUILD_DIR = ${platform_build_directory}
BUILD_DIR = ${platform_build_directory}
BIN_DIR = $(BUILD_DIR)${separator}${architecture}
LIB_DIR = $(BIN_DIR)
MODULE_BUILD_DIR = $(BUILD_DIR)${separator}${architecture}${separator}${module_relative_directory}${separator}${module_file_base_name}
OUTPUT_DIR = $(MODULE_BUILD_DIR)${separator}OUTPUT
DEBUG_DIR = $(MODULE_BUILD_DIR)${separator}DEBUG
DEST_DIR_OUTPUT = $(OUTPUT_DIR)
DEST_DIR_DEBUG = $(DEBUG_DIR)

#
# Tools Flag Macro (from platform/module description file, tools_def.txt)
#
${BEGIN}${tool_code}_FLAGS = ${module_tool_flags}
${END}

#
# Tools Path Macro
#
${BEGIN}${tool_code} = ${tool_path}
${END}

MAKE_FILE = ${makefile_path}

#
# Shell Command Macro
#
${BEGIN}${shell_command_code} = ${shell_command}
${END}

${custom_makefile_content}

#
# Target used when called from platform makefile, which will bypass the build of dependent libraries
#

pbuild: init all


#
# ModuleTarget
#

mbuild: init all


#
# Initialization target: print build information and create necessary directories
#
init:
\t-@echo Building ... $(MODULE_NAME) [$(ARCH)]
${BEGIN}\t-@${create_directory_command}\n${END}\

'''
    ## Constructor of CustomMakefile
    #
    #   @param  ModuleAutoGen   Object of ModuleAutoGen class
    #
    def __init__(self, ModuleAutoGen):
        BuildFile.__init__(self, ModuleAutoGen)
        self.PlatformInfo = self._AutoGenObject.PlatformInfo
        self.IntermediateDirectoryList = ["$(DEBUG_DIR)", "$(OUTPUT_DIR)"]

    # Compose a dict object containing information used to do replacement in template
    def _CreateTemplateDict(self):
        Separator = self._SEP_[self._FileType]
        try:
            if self._FileType not in self._AutoGenObject.CustomMakefile:
                EdkLogger.error('build', OPTION_NOT_SUPPORTED, "No custom makefile for %s" % self._FileType,
                                ExtraData="[%s]" % str(self._AutoGenObject))
            MakefilePath = os.path.join(
                                    self._AutoGenObject.WorkspaceDir,
                                    self._AutoGenObject.CustomMakefile[self._FileType]
                                    )
            CustomMakefile = open(MakefilePath, 'r').read()
        except:
            EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(self._AutoGenObject),
                            ExtraData=self._AutoGenObject.CustomMakefile[self._FileType])

        MakefileName = self._FILE_NAME_[self._FileType]
        MakefileTemplateDict = {
            "makefile_header"           : self._FILE_HEADER_[self._FileType],
            "makefile_path"             : os.path.join("$(MODULE_BUILD_DIR)", MakefileName),
            "platform_name"             : self.PlatformInfo.Name,
            "platform_guid"             : self.PlatformInfo.Guid,
            "platform_version"          : self.PlatformInfo.Version,
            "platform_relative_directory": self.PlatformInfo.SourceDir,
            "platform_output_directory" : self.PlatformInfo.OutputDir,

            "module_name"               : self._AutoGenObject.Name,
            "module_guid"               : self._AutoGenObject.Guid,
            "module_version"            : self._AutoGenObject.Version,
            "module_type"               : self._AutoGenObject.ModuleType,
            "module_file_base_name"     : self._AutoGenObject.FileBase,
            "module_relative_directory" : self._AutoGenObject.SourceDir,

            "architecture"              : self._AutoGenObject.Arch,
            "toolchain_tag"             : self._AutoGenObject.ToolChain,
            "build_target"              : self._AutoGenObject.BuildTarget,

            "platform_build_directory"  : self.PlatformInfo.BuildDir,

            "separator"                 : Separator,
            "module_tool_flags"         : [self._AutoGenObject.BuildOption[tool] for tool in self.PlatformInfo.ToolPath],

            "shell_command_code"        : self._SHELL_CMD_[self._FileType].keys(),
            "shell_command"             : self._SHELL_CMD_[self._FileType].values(),

            "tool_code"                 : self.PlatformInfo.ToolPath.keys(),
            "tool_path"                 : self.PlatformInfo.ToolPath.values(),

            "create_directory_command"  : self.GetCreateDirectoryCommand(self.IntermediateDirectoryList),
            "custom_makefile_content"   : CustomMakefile
        }

        return MakefileTemplateDict

    _TemplateDict = property(_CreateTemplateDict)

## PlatformMakefile class
#
#  This class encapsules makefie and its generation for platform. It uses
# template to generate the content of makefile. The content of makefile will be
# got from PlatformAutoGen object.
#
class PlatformMakefile(BuildFile):
    ## template used to generate the makefile for platform
    _TEMPLATE_ = '''\
${makefile_header}

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}
PLATFORM_DIR = $(WORKSPACE)${separator}${platform_relative_directory}
PLATFORM_OUTPUT_DIR = ${platform_output_directory}

#
# Build Configuration Macro Definition
#
TOOLCHAIN = ${toolchain_tag}
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}

#
# Build Directory Macro Definition
#
BUILD_DIR = ${platform_build_directory}
FV_DIR = ${platform_build_directory}${separator}FV

#
# Shell Command Macro
#
${BEGIN}${shell_command_code} = ${shell_command}
${END}

MAKE = ${make_path}
MAKE_FLAGS = ${make_flag}
MAKE_FILE = ${makefile_path}

#
# Default target
#
all: init build_libraries build_modules

#
# Initialization target: print build information and create necessary directories
#
init:
\t-@echo Building ... $(PLATFORM_NAME) [${build_architecture_list}]
\t${BEGIN}-@${create_directory_command}
\t${END}
#
# library build target
#
libraries: init build_libraries

#
# module build target
#
modules: init build_libraries build_modules

#
# Build all libraries:
#
build_libraries:
${BEGIN}\t@cd ${library_build_directory} && "$(MAKE)" $(MAKE_FLAGS) pbuild
${END}\t@cd $(BUILD_DIR)

#
# Build all modules:
#
build_modules:
${BEGIN}\t@cd ${module_build_directory} && "$(MAKE)" $(MAKE_FLAGS) pbuild
${END}\t@cd $(BUILD_DIR)

#
# Clean intermediate files
#
clean:
\t${BEGIN}@cd ${library_build_directory} && "$(MAKE)" $(MAKE_FLAGS) clean
\t${END}${BEGIN}@cd ${module_build_directory} && "$(MAKE)" $(MAKE_FLAGS) clean
\t${END}@cd $(BUILD_DIR)

#
# Clean all generated files except to makefile
#
cleanall:
${BEGIN}\t${cleanall_command}
${END}

#
# Clean all library files
#
cleanlib:
\t${BEGIN}@cd ${library_build_directory} && "$(MAKE)" $(MAKE_FLAGS) cleanall
\t${END}@cd $(BUILD_DIR)\n
'''

    ## Constructor of PlatformMakefile
    #
    #   @param  ModuleAutoGen   Object of PlatformAutoGen class
    #
    def __init__(self, PlatformAutoGen):
        BuildFile.__init__(self, PlatformAutoGen)
        self.ModuleBuildCommandList = []
        self.ModuleMakefileList = []
        self.IntermediateDirectoryList = []
        self.ModuleBuildDirectoryList = []
        self.LibraryBuildDirectoryList = []

    # Compose a dict object containing information used to do replacement in template
    def _CreateTemplateDict(self):
        Separator = self._SEP_[self._FileType]

        PlatformInfo = self._AutoGenObject
        if "MAKE" not in PlatformInfo.ToolPath:
            EdkLogger.error("build", OPTION_MISSING, "No MAKE command defined. Please check your tools_def.txt!",
                            ExtraData="[%s]" % str(self._AutoGenObject))

        self.IntermediateDirectoryList = ["$(BUILD_DIR)"]
        self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()
        self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()

        MakefileName = self._FILE_NAME_[self._FileType]
        MakefileTemplateDict = {
            "makefile_header"           : self._FILE_HEADER_[self._FileType],
            "makefile_path"             : os.path.join("$(BUILD_DIR)", MakefileName),
            "platform_name"             : PlatformInfo.Name,
            "platform_guid"             : PlatformInfo.Guid,
            "platform_version"          : PlatformInfo.Version,
            "platform_relative_directory": PlatformInfo.SourceDir,
            "platform_output_directory" : PlatformInfo.OutputDir,
            "platform_build_directory"  : PlatformInfo.BuildDir,

            "toolchain_tag"             : PlatformInfo.ToolChain,
            "build_target"              : PlatformInfo.BuildTarget,
            "make_path"                 : PlatformInfo.ToolPath["MAKE"],
            "make_flag"                 : PlatformInfo.ToolOption["MAKE"],
            "shell_command_code"        : self._SHELL_CMD_[self._FileType].keys(),
            "shell_command"             : self._SHELL_CMD_[self._FileType].values(),
            "build_architecture_list"   : self._AutoGenObject.Arch,
            "architecture"              : self._AutoGenObject.Arch,
            "separator"                 : Separator,
            "create_directory_command"  : self.GetCreateDirectoryCommand(self.IntermediateDirectoryList),
            "cleanall_command"          : self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList),
            "library_build_directory"   : self.LibraryBuildDirectoryList,
            "module_build_directory"    : self.ModuleBuildDirectoryList,
            "active_platform"           : PlatformInfo.WorkspaceDir + Separator + str(PlatformInfo),
        }

        return MakefileTemplateDict

    ## Get the root directory list for intermediate files of all modules build
    #
    #   @retval     list    The list of directory
    #
    def GetModuleBuildDirectoryList(self):
        DirList = []
        for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:
            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))
        return DirList

    ## Get the root directory list for intermediate files of all libraries build
    #
    #   @retval     list    The list of directory
    #
    def GetLibraryBuildDirectoryList(self):
        DirList = []
        for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:
            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))
        return DirList

    _TemplateDict = property(_CreateTemplateDict)

## TopLevelMakefile class
#
#  This class encapsules makefie and its generation for entrance makefile. It
# uses template to generate the content of makefile. The content of makefile
# will be got from WorkspaceAutoGen object.
#
class TopLevelMakefile(BuildFile):
    ## template used to generate toplevel makefile
    _TEMPLATE_ = '''\
${makefile_header}

#
# Platform Macro Definition
#
PLATFORM_NAME = ${platform_name}
PLATFORM_GUID = ${platform_guid}
PLATFORM_VERSION = ${platform_version}

#
# Build Configuration Macro Definition
#
TOOLCHAIN = ${toolchain_tag}
TOOLCHAIN_TAG = ${toolchain_tag}
TARGET = ${build_target}

#
# Build Directory Macro Definition
#
BUILD_DIR = ${platform_build_directory}
FV_DIR = ${platform_build_directory}${separator}FV

#
# Shell Command Macro
#
${BEGIN}${shell_command_code} = ${shell_command}
${END}

MAKE = ${make_path}
MAKE_FLAGS = ${make_flag}
MAKE_FILE = ${makefile_path}

#
# Default target
#
all: modules fds

#
# Initialization target: print build information and create necessary directories
#
init:
\t-@echo Building ... $(PLATFORM_NAME) [${build_architecture_list}]
\t${BEGIN}-@${create_directory_command}
\t${END}
#
# library build target
#
libraries: init
${BEGIN}\t@cd $(BUILD_DIR)${separator}${arch} && "$(MAKE)" $(MAKE_FLAGS) libraries
${END}\t@cd $(BUILD_DIR)

#
# module build target
#
modules: init
${BEGIN}\t@cd $(BUILD_DIR)${separator}${arch} && "$(MAKE)" $(MAKE_FLAGS) modules
${END}\t@cd $(BUILD_DIR)

#
# Flash Device Image Target
#
fds: init
\t-@cd $(FV_DIR)
${BEGIN}\tGenFds -f ${fdf_file} -o $(BUILD_DIR) -t $(TOOLCHAIN) -b $(TARGET) -p ${active_platform} -a ${build_architecture_list} ${log_level}${END}${BEGIN} -r ${fd} ${END}${BEGIN} -i ${fv} ${END}${BEGIN} -D ${macro} ${END}

#
# run command for emulator platform only
#
run:
\tcd $(BUILD_DIR)${separator}IA32
\tSecMain
\tcd $(BUILD_DIR)

#
# Clean intermediate files
#
clean:
${BEGIN}\t@cd $(BUILD_DIR)${separator}${arch} && "$(MAKE)" $(MAKE_FLAGS) clean
${END}\t@cd $(BUILD_DIR)

#
# Clean all generated files except to makefile
#
cleanall:
${BEGIN}\t${cleanall_command}
${END}

#
# Clean all library files
#
cleanlib:
${BEGIN}\t@cd $(BUILD_DIR)${separator}${arch} && "$(MAKE)" $(MAKE_FLAGS) cleanlib
${END}\t@cd $(BUILD_DIR)\n
'''

    ## Constructor of TopLevelMakefile
    #
    #   @param  Workspace   Object of WorkspaceAutoGen class
    #
    def __init__(self, Workspace):
        BuildFile.__init__(self, Workspace)
        self.IntermediateDirectoryList = []

    # Compose a dict object containing information used to do replacement in template
    def _CreateTemplateDict(self):
        Separator = self._SEP_[self._FileType]

        # any platform autogen object is ok because we just need common information
        PlatformInfo = self._AutoGenObject

        if "MAKE" not in PlatformInfo.ToolPath:
            EdkLogger.error("build", OPTION_MISSING, "No MAKE command defined. Please check your tools_def.txt!",
                            ExtraData="[%s]" % str(self._AutoGenObject))

        for Arch in PlatformInfo.ArchList:
            self.IntermediateDirectoryList.append(Separator.join(["$(BUILD_DIR)", Arch]))
        self.IntermediateDirectoryList.append("$(FV_DIR)")

        # TRICK: for not generating GenFds call in makefile if no FDF file
        MacroList = []
        if PlatformInfo.FdfFile != None and PlatformInfo.FdfFile != "":
            FdfFileList = [PlatformInfo.FdfFile]
            # macros passed to GenFds
            for MacroName in GlobalData.gGlobalDefines:
                MacroList.append('"%s=%s"' % (MacroName, GlobalData.gGlobalDefines[MacroName]))
        else:
            FdfFileList = []

        # pass log level to external program called in makefile, currently GenFds.exe
        LogLevel = EdkLogger.GetLevel()
        if LogLevel == EdkLogger.VERBOSE:
            LogOption = "-v"
        elif LogLevel <= EdkLogger.DEBUG_9:
            LogOption = "-d %d" % (LogLevel - 1)
        elif LogLevel == EdkLogger.QUIET:
            LogOption = "-q"
        else:
            LogOption = ""

        MakefileName = self._FILE_NAME_[self._FileType]
        MakefileTemplateDict = {
            "makefile_header"           : self._FILE_HEADER_[self._FileType],
            "makefile_path"             : os.path.join("$(BUILD_DIR)", MakefileName),
            "platform_name"             : PlatformInfo.Name,
            "platform_guid"             : PlatformInfo.Guid,
            "platform_version"          : PlatformInfo.Version,
            "platform_build_directory"  : PlatformInfo.BuildDir,

            "toolchain_tag"             : PlatformInfo.ToolChain,
            "build_target"              : PlatformInfo.BuildTarget,
            "make_path"                 : PlatformInfo.ToolPath["MAKE"],
            "make_flag"                 : PlatformInfo.ToolOption["MAKE"],
            "shell_command_code"        : self._SHELL_CMD_[self._FileType].keys(),
            "shell_command"             : self._SHELL_CMD_[self._FileType].values(),
            'arch'                      : list(PlatformInfo.ArchList),
            "build_architecture_list"   : ','.join(PlatformInfo.ArchList),
            "separator"                 : Separator,
            "create_directory_command"  : self.GetCreateDirectoryCommand(self.IntermediateDirectoryList),
            "cleanall_command"          : self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList),
            "fdf_file"                  : FdfFileList,
            "active_platform"           : PlatformInfo.WorkspaceDir + Separator + str(PlatformInfo),
            "fd"                        : PlatformInfo.FdTargetList,
            "fv"                        : PlatformInfo.FvTargetList,
            "log_level"                 : LogOption,
            "macro"                     : MacroList,
        }

        return MakefileTemplateDict

    ## Get the root directory list for intermediate files of all modules build
    #
    #   @retval     list    The list of directory
    #
    def GetModuleBuildDirectoryList(self):
        DirList = []
        for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:
            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))
        return DirList

    ## Get the root directory list for intermediate files of all libraries build
    #
    #   @retval     list    The list of directory
    #
    def GetLibraryBuildDirectoryList(self):
        DirList = []
        for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:
            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))
        return DirList

    _TemplateDict = property(_CreateTemplateDict)

# This acts like the main() function for the script, unless it is 'import'ed into another script.
if __name__ == '__main__':
    pass

